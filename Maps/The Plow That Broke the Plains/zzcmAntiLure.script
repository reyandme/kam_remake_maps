Const DEF = -1; YES = 1; NO = 0; //<---PLEASE DO NOT CHANGE THESE!

(*"Anti-Lure" (AL) . . . A script by cmowla (June 10, 2023). [Last updated on December 13, 2024] (v4.4b ... Minimal Lag version)
- Tested on r15122.
- I want to give a VERY SPECIAL thanks to DontTalk for giving me ideas and feedback, but also for believing in me to write a script like this!  (We exchanged A LOT of DMs about so many different things pertaining to the development of this script, I don't know where to begin!  He was extremely patient with me during the process as well.)
- I also thank Klaas (KW) for helping me test this during development somewhat as well.


(If you experience any problems, don't be shy to contact my on Discord about it, AS I DON'T INTEND TO MAKE ANOTHER UPDATE TO THIS SCRIPT UNLESS THERE IS AN ISSUE.)

_________________________________________________________________________________________
How to Use:
[1] Put "{$Include zzcmAntiLure.script}" (without quotes) at the beginning of the map's script.
[2] Change the values of the constants below to have the desired effect.
	- All CONSTANTS below except for REMOVE_AUTO_ATTACK_RANGE and RANGED_DECOY_COUNT (which apply to ALL players) represent the default for ALL players.
	- But further down are tables for players 1 - 30 in which each player can have a custom value for each.
	- The more care you as the map maker take in tailoring these to the different AI players to your map, the better AntiLure will work!
[3] This (minimal lag) version of this script requires a supporting scripte named "zzcmDefencePositionInfoArray.script".
	- You must create this script by running the external App that I wrote which autogenerates it.
	- The app is named "Defence Position Info Array Updater v1.0.hta" and should have been in the folder for which you downloaded this script from.
	- Simply put this app IN THE MAP FOLDER, double click on the app to run, input the map's Width and then the map's height (follow the prompts).  After a few seconds (at most), a script named "zzcmDefencePositionInfoArray.script" should be created in the map folder, and it's ready to use!
	- IMPORTANT NOTE:  Any time you make a change to the AI's defense positions (in ANY WAY), you need to rerun this app to recreate/update "zzcmDefencePositionInfoArray.script".  Very important!

_________________________________________________________________________________________
Script Limitations:

This script cannot save AI groups from lure if:

(1) Defense locations are not set.
	- It specifically searches if an attack was made on a tile (x,y) that IS IN A DEFENSE CIRCLE.
	- This limitation can be removed, but for almost every GOOD map that I'm aware of, defense locations will be set at the start of the game.  (It will be a rare occurrence... on GOOD MAPS ... that this is actually a limitation.)

(2) The AI player defends a human player and the human player is being attacked or if it's AI against AI.
	- This script is only designed to prevent lure for human assaults on AI and AI assaults on humans (both in AI territory).
	- However, it's not going to be a common occurrence when this type of situation happens (human AI allys getting abused by human opponents to humans).

(3) New defense locations are made during the game which previous defense locations did NOT defend.
	- It's not necessarily a deal-breaker, but IT IS A VULNERABILITY (AI groups stationed at those new defense locations will be completely vulnerable to lure as they are by default).
	- This limitation can be removed, but it exists to remove a significant amount of lag.

(4) Any non-ranged group's autoattack range is > 1.
	- This script prevents lure from these groups should a nearby unit or house be hit.  But getting within close proximity to them (while they're idle) will result in them following the decoy FOREVER (as usual).
	- Simple fix is to make all non-ranged unit groups autoattack range = 1.
	- The first constant below allows you to do this automatically (with this script).

(5) There are two versions of this script.  This one requires a LARGE script file named "zzcmDefencePositionInfoArray.script".  (A file autogenerated by an external HTA application I wrote which creates a map of how every tile is defended by which groups from which player.)
	- This version has MUCH LESS LAG than the one without it.
	- The big change is making Player_Get_All_Defending_Groups(...) MUCH LESS TAXING!  (It doesn't loop through all defense locations of all AI players.)
	- Lastly, loading in all of the data in the LARGE script file ("zzcmDefencePositionInfoArray.script") will delay the game's start by MAYBE a second or 2 (at most), but after that, there should be NO VISIBLE LAG for the rest of the game.

_________________________________________________________________________________________
SETTINGS:


Regarding (4) from above, you can simply set the following to YES, and it will take care of that vulnerability.*)
REMOVE_AUTO_ATTACK_RANGE = YES;



(*_______________________________________________________________________________________
 Number of bowman, crossbowmen, or rogues to tell AI to only send 1 group after it.  (Halt all others immediately.)
- Set to 0 if you want to "disable" this feature.*)
RANGED_DECOY_COUNT = 1;



(*_______________________________________________________________________________________
 Number of non-ranged (melee, mounted, anti-horse) to tell AI to only send 1 group after it.  (Halt all others immediately.)
- Set to 0 if you want to "disable" this feature.  Separate from ranged because mounted units are easier to use to lure, for example.*)
NONRANGED_DECOY_COUNT = 1;


(*_______________________________________________________________________________________
Set all 4 of these = 0 if you don't want to return to their posts based on time delay.
- You are allowed to set different delays (in seconds) for each of the 4 group types.
- Due to mounted units faster speed, it may be ideal to set a longer delay for them to pursue.  (If these values are chosen with care, they can make it back to their posts at the same time as the foot soldiers.)
- Due to ranged units' vulnerability to flanking, it may be ideal to set a shorter delay for them to pursue.
- (It may be helpful to know that mounted units move about 1.66 times as fast as foot soldiers when setting the times.)
- All values represent SECONDS.*)
RANGED_DELAY = 5;
ANTIHORSE_DELAY = 7;
MELEE_DELAY = 7;
MOUNTED_DELAY = 9;


(*In addition to setting the above delays, if RANDOM_DELAY_MULTIPLIER = YES, then a random number (between 1 and 3) will be multiplied by those amounts upon every check.*)
RANDOM_DELAY_MULTIPLIER = NO;


(*_______________________________________________________________________________________
For the cases when an AI unit/group is attacked in some way...OR when an human player's unit is attacked by AI in AI territory (where "AI territory" means wherever defense locations are).

This is the minimum distance the attacking unit/decoy must be away from the leader of the group that he attacked (before those groups will go home... regardless of the time delay set, should the distance imply a longer delay).

This comes in handy to compensate for attempting to abuse the time delays, because even if the time delays HAVE EXPIRED, if the decoy is still within range, the AI will pursue him.  (This effectively makes the AI aggressive to discourage human players from attempting to lure out multiple groups from the outskirts of its village.)

But should the duration of time that is set for them to return to their posts has expired once the attacking unit/decoy is UNIT_DISTANCE tiles or more away, the groups will all (at the same time) return to their posts . . . should RESET_TIMER be set to NO.

Setting UNIT_DISTANCE to 0 will effectively DISABLE this feature, but if considered, note that:

- This script considers the SPECIFIC UNIT of the group that attacked for this distance, not the closest unit in the group when it comes time to check (should the decoy either be a part of a group at the time of the offense OR the other units joined to the decoy after the offense).

- Should the group that the human player's decoy (most likely a bowman) attacks IS DEAD by the time it's time to check the distance that he's away from the group, then the distance he is (now) away from the tile (x,y) where he made the offense will used (rather than the distance away from the group that he attacked... because it's dead, so we cannot "find where it is").*)
UNIT_DISTANCE = 0;


(*_______________________________________________________________________________________
For the cases when a unit/group attacks an AI player's building/house.

Until the attacking unit/decoy is BUILDING_DISTANCE away from where he was when he attacked the building, the AI groups will continue to pursue the decoy.

- This is not necessarily the location (x,y) that the building's door is in the map editor... just the actual tile (x,y) where he made the offense.

- This effectively handles the case when the house happens to get destroyed during the pursuit... that is, we don't look to where the location of the house is that he attacked when it's time to check!  We instead look to this tile (x,y) where he attacked the house from.

(Just like for UNIT_DISTANCE, this comes in handy to compensate for attempting to abuse the time delays.  And this effectively makes the AI much more aggressive to discourage sneaking into villages!)

But should the duration of time that is set for them to return to their posts has expired once the attacking unit/decoy is BUILDING_DISTANCE tiles or more away from the location (x,y) where he attacked the building/house, the groups will all (at the same time) return to their posts . . . should RESET_TIMER be set to NO.

But if RESET_TIMER is YES, then once the decoy is BUILDING_DISTANCE away from the point (x,y) when he attacked a building, the group types will return to their posts in the order that is determined by the times in which each group type is set (by you) to return.*)
BUILDING_DISTANCE = 5;


(*_______________________________________________________________________________________
See the last 2 bullet points under the comments above BUILDING_DISTANCE.)*)
RESET_TIMER = YES;


(*_______________________________________________________________________________________
Should an AI's villager (of any kind, including recruits) be attacked, if not set to 0 (which would effectively disable this feature), this represents the minimum distance the human player decoy must be away from the closest building/house (that is owned by the AI player that he attacked) from the tile (x,y) from which he attacked the villager.

- The villager most likely will die from the attack, and thus we cannot search for his current position MOST OF THE TIME when it's time to check if the human player's decoy is far enough away.*)
VILLAGER_DISTANCE = 0;


(*_______________________________________________________________________________________
Just like there is a random multiplier for delays, there is one for distances.

- If set to YES, it will be applied (and it will be applied to every check), but only a random integer between 1 and 2 (not between 1 and 3).

- It applies to UNIT, BUILDING, and VILLAGER distances.*)
RANDOM_DISTANCE_MULTIPLIER = NO;


(*_______________________________________________________________________________________
If set to a distance < the other constants will naturally force, this is the MAXIMUM allowed distance a group can be from its defense position.
- Set to 255 (largest map dimension) to effectively disable this additional means to halt groups after a certain period of time, since it potentially WILL interfere with the timings.*)
DEFENSE_POSITION_DISTANCE = 255;


(*_______________________________________________________________________________________
If YES, then my (cmowla's) link-before-dead (LBD) trick will still work, despite all other types of lure not working. But if NO, then my link-before-dead will NOT work!*)
LINK_BEFORE_DEAD_IS_ALLOWED = NO;



(*_______________________________________________________________________________________
Below are tables for most of the constants above.
- They allow you to set different values for different players!
- You only need to set values for the specific AI players that are on the map.  (If players don't exist, it doesn't matter.)
- Currently this script assumes that there are up to 30 players on a map (human and AI).  But if in the future there is more, you will need to manually edit the Case switch statements (add in more player numbers)!*)


Function Ranged_Delays(player: Integer): Integer;
var rangedDelay: Integer; begin Case player of //Put an integer (for seconds) or def (for Default)
	1: rangedDelay := def;	11: rangedDelay := def;	21: rangedDelay := def;
	2: rangedDelay := def;	12: rangedDelay := def;	22: rangedDelay := def;
	3: rangedDelay := def;	13: rangedDelay := def;	23: rangedDelay := def;
	4: rangedDelay := def;	14: rangedDelay := def;	24: rangedDelay := def;
	5: rangedDelay := def;	15: rangedDelay := def;	25: rangedDelay := def;
	6: rangedDelay := def;	16: rangedDelay := def;	26: rangedDelay := def;
	7: rangedDelay := def;	17: rangedDelay := def;	27: rangedDelay := def;
	8: rangedDelay := def;	18: rangedDelay := def;	28: rangedDelay := def;
	9: rangedDelay := def;	19: rangedDelay := def;	29: rangedDelay := def;
	10: rangedDelay := def;	20: rangedDelay := def;	30: rangedDelay := def;
end;Result:=rangedDelay;end;


Function AntiHorse_Delays(player: Integer): Integer;
var antiHorseDelay: Integer; begin Case player of //Put an integer (for seconds) or def (for Default)
	1: antiHorseDelay := def;	11: antiHorseDelay := def;	21: antiHorseDelay := def;
	2: antiHorseDelay := def;	12: antiHorseDelay := def;	22: antiHorseDelay := def;
	3: antiHorseDelay := def;	13: antiHorseDelay := def;	23: antiHorseDelay := def;
	4: antiHorseDelay := def;	14: antiHorseDelay := def;	24: antiHorseDelay := def;
	5: antiHorseDelay := def;	15: antiHorseDelay := def;	25: antiHorseDelay := def;
	6: antiHorseDelay := def;	16: antiHorseDelay := def;	26: antiHorseDelay := def;
	7: antiHorseDelay := def;	17: antiHorseDelay := def;	27: antiHorseDelay := def;
	8: antiHorseDelay := def;	18: antiHorseDelay := def;	28: antiHorseDelay := def;
	9: antiHorseDelay := def;	19: antiHorseDelay := def;	29: antiHorseDelay := def;
	10: antiHorseDelay := def;	20: antiHorseDelay := def;	30: antiHorseDelay := def;
end;Result:=antiHorseDelay;end;


Function Melee_Delays(player: Integer): Integer;
var meleeDelay: Integer; begin Case player of //Put an integer (for seconds) or def (for Default)
	1: meleeDelay := def;	11: meleeDelay := def;	21: meleeDelay := def;
	2: meleeDelay := def;	12: meleeDelay := def;	22: meleeDelay := def;
	3: meleeDelay := def;	13: meleeDelay := def;	23: meleeDelay := def;
	4: meleeDelay := def;	14: meleeDelay := def;	24: meleeDelay := def;
	5: meleeDelay := def;	15: meleeDelay := def;	25: meleeDelay := def;
	6: meleeDelay := def;	16: meleeDelay := def;	26: meleeDelay := def;
	7: meleeDelay := def;	17: meleeDelay := def;	27: meleeDelay := def;
	8: meleeDelay := def;	18: meleeDelay := def;	28: meleeDelay := def;
	9: meleeDelay := def;	19: meleeDelay := def;	29: meleeDelay := def;
	10: meleeDelay := def;	20: meleeDelay := def;	30: meleeDelay := def;
end;Result:=meleeDelay;end;


Function Mounted_Delays(player: Integer): Integer;
var mountedDelay: Integer; begin Case player of //Put an integer (for seconds) or def (for Default)
	1: mountedDelay := def;		11: mountedDelay := def;	21: mountedDelay := def;
	2: mountedDelay := def;		12: mountedDelay := def;	22: mountedDelay := def;
	3: mountedDelay := def;		13: mountedDelay := def;	23: mountedDelay := def;
	4: mountedDelay := def;		14: mountedDelay := def;	24: mountedDelay := def;
	5: mountedDelay := def;		15: mountedDelay := def;	25: mountedDelay := def;
	6: mountedDelay := def;		16: mountedDelay := def;	26: mountedDelay := def;
	7: mountedDelay := def;		17: mountedDelay := def;	27: mountedDelay := def;
	8: mountedDelay := def;		18: mountedDelay := def;	28: mountedDelay := def;
	9: mountedDelay := def;		19: mountedDelay := def;	29: mountedDelay := def;
	10: mountedDelay := def;	20: mountedDelay := def;	30: mountedDelay := def;
end;Result:=mountedDelay;end;


Function Unit_Distances(player: Integer): Integer;
var unitDistance: Integer; begin Case player of //Put an integer (for tiles) or def (for Default)
	1: unitDistance := def;		11: unitDistance := def;	21: unitDistance := def;
	2: unitDistance := def;		12: unitDistance := def;	22: unitDistance := def;
	3: unitDistance := def;		13: unitDistance := def;	23: unitDistance := def;
	4: unitDistance := def;		14: unitDistance := def;	24: unitDistance := def;
	5: unitDistance := def;		15: unitDistance := def;	25: unitDistance := def;
	6: unitDistance := def;		16: unitDistance := def;	26: unitDistance := def;
	7: unitDistance := def;		17: unitDistance := def;	27: unitDistance := def;
	8: unitDistance := def;		18: unitDistance := def;	28: unitDistance := def;
	9: unitDistance := def;		19: unitDistance := def;	29: unitDistance := def;
	10: unitDistance := def;	20: unitDistance := def;	30: unitDistance := def;
end;Result:=unitDistance;end;


Function Building_Distances(player: Integer): Integer;
var buildingDistance: Integer; begin Case player of //Put an integer (for tiles) or def (for Default)
	1: buildingDistance := def;		11: buildingDistance := def;	21: buildingDistance := def;
	2: buildingDistance := def;		12: buildingDistance := def;	22: buildingDistance := def;
	3: buildingDistance := def;		13: buildingDistance := def;	23: buildingDistance := def;
	4: buildingDistance := def;		14: buildingDistance := def;	24: buildingDistance := def;
	5: buildingDistance := def;		15: buildingDistance := def;	25: buildingDistance := def;
	6: buildingDistance := def;		16: buildingDistance := def;	26: buildingDistance := def;
	7: buildingDistance := def;		17: buildingDistance := def;	27: buildingDistance := def;
	8: buildingDistance := def;		18: buildingDistance := def;	28: buildingDistance := def;
	9: buildingDistance := def;		19: buildingDistance := def;	29: buildingDistance := def;
	10: buildingDistance := def;	20: buildingDistance := def;	30: buildingDistance := def;
end;Result:=buildingDistance;end;


Function Villager_Distances(player: Integer): Integer;
var villagerDistance: Integer; begin Case player of //Put an integer (for tiles) or def (for Default)
	1: villagerDistance := def;		11: villagerDistance := def;	21: villagerDistance := def;
	2: villagerDistance := def;		12: villagerDistance := def;	22: villagerDistance := def;
	3: villagerDistance := def;		13: villagerDistance := def;	23: villagerDistance := def;
	4: villagerDistance := def;		14: villagerDistance := def;	24: villagerDistance := def;
	5: villagerDistance := def;		15: villagerDistance := def;	25: villagerDistance := def;
	6: villagerDistance := def;		16: villagerDistance := def;	26: villagerDistance := def;
	7: villagerDistance := def;		17: villagerDistance := def;	27: villagerDistance := def;
	8: villagerDistance := def;		18: villagerDistance := def;	28: villagerDistance := def;
	9: villagerDistance := def;		19: villagerDistance := def;	29: villagerDistance := def;
	10: villagerDistance := def;	20: villagerDistance := def;	30: villagerDistance := def;
end;Result:=villagerDistance;end;


Function Defense_Position_Distances(player: Integer): Integer;
var defPosDistance: Integer; begin Case player of //Put an integer (for tiles) or def (for Default)
	1: defPosDistance := def;	11: defPosDistance := def;	21: defPosDistance := def;
	2: defPosDistance := def;	12: defPosDistance := def;	22: defPosDistance := def;
	3: defPosDistance := def;	13: defPosDistance := def;	23: defPosDistance := def;
	4: defPosDistance := def;	14: defPosDistance := def;	24: defPosDistance := def;
	5: defPosDistance := def;	15: defPosDistance := def;	25: defPosDistance := def;
	6: defPosDistance := def;	16: defPosDistance := def;	26: defPosDistance := def;
	7: defPosDistance := def;	17: defPosDistance := def;	27: defPosDistance := def;
	8: defPosDistance := def;	18: defPosDistance := def;	28: defPosDistance := def;
	9: defPosDistance := def;	19: defPosDistance := def;	29: defPosDistance := def;
	10: defPosDistance := def;	20: defPosDistance := def;	30: defPosDistance := def;
end;Result:=defPosDistance;end;


Function Random_Delay_Multipliers(player: Integer): Integer;
var randDelayMult: Integer; begin Case player of //Type yes, no, or def (for Default)
	1: randDelayMult := def;	11: randDelayMult := def;	21: randDelayMult := def;
	2: randDelayMult := def;	12: randDelayMult := def;	22: randDelayMult := def;
	3: randDelayMult := def;	13: randDelayMult := def;	23: randDelayMult := def;
	4: randDelayMult := def;	14: randDelayMult := def;	24: randDelayMult := def;
	5: randDelayMult := def;	15: randDelayMult := def;	25: randDelayMult := def;
	6: randDelayMult := def;	16: randDelayMult := def;	26: randDelayMult := def;
	7: randDelayMult := def;	17: randDelayMult := def;	27: randDelayMult := def;
	8: randDelayMult := def;	18: randDelayMult := def;	28: randDelayMult := def;
	9: randDelayMult := def;	19: randDelayMult := def;	29: randDelayMult := def;
	10: randDelayMult := def;	20: randDelayMult := def;	30: randDelayMult := def;
end;Result:=randDelayMult;end;


Function Random_Distance_Multipliers(player: Integer): Integer;
var randDistMult: Integer; begin Case player of //Type yes, no, or def (for Default)
	1: randDistMult := def;		11: randDistMult := def;	21: randDistMult := def;
	2: randDistMult := def;		12: randDistMult := def;	22: randDistMult := def;
	3: randDistMult := def;		13: randDistMult := def;	23: randDistMult := def;
	4: randDistMult := def;		14: randDistMult := def;	24: randDistMult := def;
	5: randDistMult := def;		15: randDistMult := def;	25: randDistMult := def;
	6: randDistMult := def;		16: randDistMult := def;	26: randDistMult := def;
	7: randDistMult := def;		17: randDistMult := def;	27: randDistMult := def;
	8: randDistMult := def;		18: randDistMult := def;	28: randDistMult := def;
	9: randDistMult := def;		19: randDistMult := def;	29: randDistMult := def;
	10: randDistMult := def;	20: randDistMult := def;	30: randDistMult := def;
end;Result:=randDistMult;end;


Function Reset_Timers(player: Integer): Integer;
var resetTimer: Integer; begin Case player of //Type yes, no, or def (for Default)
	1: resetTimer := def;	11: resetTimer := def;	21: resetTimer := def;
	2: resetTimer := def;	12: resetTimer := def;	22: resetTimer := def;
	3: resetTimer := def;	13: resetTimer := def;	23: resetTimer := def;
	4: resetTimer := def;	14: resetTimer := def;	24: resetTimer := def;
	5: resetTimer := def;	15: resetTimer := def;	25: resetTimer := def;
	6: resetTimer := def;	16: resetTimer := def;	26: resetTimer := def;
	7: resetTimer := def;	17: resetTimer := def;	27: resetTimer := def;
	8: resetTimer := def;	18: resetTimer := def;	28: resetTimer := def;
	9: resetTimer := def;	19: resetTimer := def;	29: resetTimer := def;
	10: resetTimer := def;	20: resetTimer := def;	30: resetTimer := def;
end;Result:=resetTimer;end;


Function Link_Before_Deads_Allowed(player: Integer): Integer;
var linkBeforeDead: Integer; begin Case player of //Type yes, no, or def (for Default)
	1: linkBeforeDead := def;	11: linkBeforeDead := def;	21: linkBeforeDead := def;
	2: linkBeforeDead := def;	12: linkBeforeDead := def;	22: linkBeforeDead := def;
	3: linkBeforeDead := def;	13: linkBeforeDead := def;	23: linkBeforeDead := def;
	4: linkBeforeDead := def;	14: linkBeforeDead := def;	24: linkBeforeDead := def;
	5: linkBeforeDead := def;	15: linkBeforeDead := def;	25: linkBeforeDead := def;
	6: linkBeforeDead := def;	16: linkBeforeDead := def;	26: linkBeforeDead := def;
	7: linkBeforeDead := def;	17: linkBeforeDead := def;	27: linkBeforeDead := def;
	8: linkBeforeDead := def;	18: linkBeforeDead := def;	28: linkBeforeDead := def;
	9: linkBeforeDead := def;	19: linkBeforeDead := def;	29: linkBeforeDead := def;
	10: linkBeforeDead := def;	20: linkBeforeDead := def;	30: linkBeforeDead := def;
end;Result:=linkBeforeDead;end;



(*-------------------------------------------
|____________CODE STARTS NOW________________|
--------------------------------------------*)
Var aiPlayersAL, humanPlayersAL: Array of Integer;

//---------------------
//Debugging Subroutines
//---------------------
	Function AL__GroupType_String(groupType: TKMGroupType): String;
	begin //Called in Player_Get_All_Defending_Groups
		Case groupType of
			gtMelee : Result := 'Melee';
			gtAntiHorse : Result := 'Anti-Horse';
			gtRanged : Result := 'Ranged';
			gtMounted : Result := 'Mounted';
		end;
	end;

	Procedure AL__Print(str: String);
	begin
		Actions.Log(str);
	end;

	Procedure  AL__PrintI(description: String; num: Integer);
	begin
		Actions.Log(description + ':  ' + IntToStr(num));
	end;

	Procedure AL__PrintB(description: String; bool: Boolean);
	begin
		If bool Then Actions.Log(description + ':  (True)') Else Actions.Log(description + ':  (False)');
	end;

	Procedure AL__Print_ArrayI(description: String; arr: Array of Integer);
	var i: Integer; str: String;
	begin
		For i := Low(arr) to High(arr) do begin
			str := str + IntToStr(arr[i]);
			If i < High(arr) Then str := str + '|';
		end;
		Actions.Log(description + ':');
		Actions.Log(str);
	end;

	Procedure AL__Print_ArrayI_2D(description: String; arr: Array of Array of Integer);
	var i, j: Integer; str, str2: String;
	begin
		For i := Low(arr) to High(arr) do begin
			str := '';
			For j := Low(arr[i]) to High(arr[i]) do str := str + IntToStr(arr[i][j]) + ',';
			str2 := str2 + Copy(str, 1, Length(str) - 1) + '|';
		end;
		Actions.Log(description + ':');
		Actions.Log(str2);
	end;

	Procedure AL__Quit;
	var i: Integer;
	begin //It's good to put "AL__Quit; Exit;" as a line in any given procedure/function when using this.
		For i := Low(aiPlayersAL) to High(aiPlayersAL) do Actions.PlayerDefeat(aiPlayersAL[i]);
		For i := Low(humanPlayersAL) to High(humanPlayersAL) do Actions.PlayerDefeat(humanPlayersAL[i]);
	end;


//----------------------------------------
{$Include zzcmDefencePositionInfoArray.script}
Var
	rangedDelays, antiHorseDelays, meleeDelays, mountedDelays,
	unitDistances, buildingDistances, villagerDistances, defensePositionDistances,
	randomDelayMultipliers, randomDistanceMultipliers, resetTimers, linkBeforeDeads: Array of Integer;
	weights, defenderDefensePositions: Array of Array of Integer;
	mapWidth: Integer;

Const
	RANGED_DELAY_ = 0;
	ANTIHORSE_DELAY_ = 1;
	MELEE_DELAY_ = 2;
	MOUNTED_DELAY_ = 3;
	UNIT_DISTANCE_ = 4;
	BUILDING_DISTANCE_ = 5;
	VILLAGER_DISTANCE_ = 6;
	DEFENSE_POSITION_DISTANCE_ = 7;
	RANDOM_DELAY_MULTIPLIER_ = 8;
	RANDOM_DISTANCE_MULTIPLIER_ = 9;
	RESET_TIMER_ = 10;
	LINK_BEFORE_DEAD_ALLOWED_ = 11;


Procedure AL__Initialize_CONSTANTS;
var i, locCnt: Integer;
begin
	locCnt := S.LocationCount;

	SetLength(rangedDelays, locCnt);
	For i := 0 to locCnt - 1 do
		If Ranged_Delays(i + 1) = def
		Then rangedDelays[i] := RANGED_DELAY
		Else rangedDelays[i] := Ranged_Delays(i + 1);

	SetLength(antiHorseDelays, locCnt);
	For i := 0 to locCnt - 1 do
		If AntiHorse_Delays(i + 1) = def
		Then antiHorseDelays[i] := ANTIHORSE_DELAY
		Else antiHorseDelays[i] := AntiHorse_Delays(i + 1);

	SetLength(meleeDelays, locCnt);
	For i := 0 to locCnt - 1 do
		If Melee_Delays(i + 1) = def
		Then meleeDelays[i] := MELEE_DELAY
		Else meleeDelays[i] := Melee_Delays(i + 1);

	SetLength(mountedDelays, locCnt);
	For i := 0 to locCnt - 1 do
		If Mounted_Delays(i + 1) = def
		Then mountedDelays[i] := MOUNTED_DELAY
		Else mountedDelays[i] := Mounted_Delays(i + 1);

	SetLength(unitDistances, locCnt);
	For i := 0 to locCnt - 1 do
		If Unit_Distances(i + 1) = def
		Then unitDistances[i] := UNIT_DISTANCE
		Else unitDistances[i] := Unit_Distances(i + 1);

	SetLength(buildingDistances, locCnt);
	For i := 0 to locCnt - 1 do
		If Building_Distances(i + 1) = def
		Then buildingDistances[i] := BUILDING_DISTANCE
		Else buildingDistances[i] := Building_Distances(i + 1);

	SetLength(villagerDistances, locCnt);
	For i := 0 to locCnt - 1 do
		If Villager_Distances(i + 1) = def
		Then villagerDistances[i] := VILLAGER_DISTANCE
		Else villagerDistances[i] := Villager_Distances(i + 1);

	SetLength(defensePositionDistances, locCnt);
	For i := 0 to locCnt - 1 do
		If Defense_Position_Distances(i + 1) = def
		Then defensePositionDistances[i] := DEFENSE_POSITION_DISTANCE
		Else defensePositionDistances[i] := Defense_Position_Distances(i + 1);

	SetLength(randomDelayMultipliers, locCnt);
	For i := 0 to locCnt - 1 do
		If Random_Delay_Multipliers(i + 1) = def
		Then randomDelayMultipliers[i] := RANDOM_DELAY_MULTIPLIER
		Else randomDelayMultipliers[i] := Random_Delay_Multipliers(i + 1);

	SetLength(randomDistanceMultipliers, locCnt);
	For i := 0 to locCnt - 1 do
		If Random_Distance_Multipliers(i + 1) = def
		Then randomDistanceMultipliers[i] := RANDOM_DISTANCE_MULTIPLIER
		Else randomDistanceMultipliers[i] := Random_Distance_Multipliers(i + 1);

	SetLength(resetTimers, locCnt);
	For i := 0 to locCnt - 1 do
		If Reset_Timers(i + 1) = def
		Then resetTimers[i] := RESET_TIMER
		Else resetTimers[i] := Reset_Timers(i + 1);

	SetLength(linkBeforeDeads, locCnt);
	For i := 0 to locCnt - 1 do
		If Link_Before_Deads_Allowed(i + 1) = def
		Then linkBeforeDeads[i] := LINK_BEFORE_DEAD_IS_ALLOWED
		Else linkBeforeDeads[i] := Link_Before_Deads_Allowed(i + 1);

	SetLength(weights, 12);
	weights[RANGED_DELAY_] := rangedDelays;
	weights[ANTIHORSE_DELAY_] := antiHorseDelays;
	weights[MELEE_DELAY_] := meleeDelays;
	weights[MOUNTED_DELAY_] := mountedDelays;
	weights[UNIT_DISTANCE_] := unitDistances;
	weights[BUILDING_DISTANCE_] := buildingDistances;
	weights[VILLAGER_DISTANCE_] := villagerDistances;
	weights[DEFENSE_POSITION_DISTANCE_] := defensePositionDistances;
	weights[RANDOM_DELAY_MULTIPLIER_] := randomDelayMultipliers;
	weights[RANDOM_DISTANCE_MULTIPLIER_] := randomDistanceMultipliers;
	weights[RESET_TIMER_] := resetTimers;
	weights[LINK_BEFORE_DEAD_ALLOWED_] := linkBeforeDeads;
end;


(*------------------------
Recorded attack properties
-------------------------*)
Const
	X__ = 0;
	Y__ = 1;
	TIME__ = 2;
	TYPE_ATTACKED_ = 3; //0 if unit, 1 if house.
	TARGETED_PLAYER_ = 4;//Player that was attacked
	TARGETED_GROUP_ID_ = 5;//ID of the group that was attacked.  Needed to determine if unit dies.
	TARGETED_UNIT_TYPE_ = 6;//Unit type constant.  Needed to distinguish between soldier and villager.
	ATTACKER_UNIT_ID_ = 7; //Needed to track his current position and if he died (for LBD trick).
	ATTACKER_GROUP_ID_ = 8; //Needed to track if his group is still alive after he dies (for LBD trick).
	ATTACKER_PLAYER_ = 9; //Needed to allow scheduled attackNearestUnit attack waves.
	TIME_WAS_RESET_ = 10;

	(*An argument which tells how many AI groups who respond to an attack.

	- The remaining arguments of the array are the group IDs of all AI groups who respond to an attack the (x,y) where the offense took place happened in their defense circle/radius, each followed by their defense.x and defense.y.

	- They are either groups owned by the AI player that was attacked or its allies' groups.

	- If either all members in the group die OR the group has been halted/told to return to their post, -1 will be written in place of the groupID number.*)
	GROUP_IDS_TO_HALT_ = 11;

//------------------------
(*Parameters for attacked AI ranged units:
	They are very much needed to prevent ranged from being lured.  (DO NOT CHANGE THESE!  These are a part of the code!)
	Some situations include:

	- If a human player uses a bowmen to fire at a ranged group from the side, where the defense radius of the ranged group is not large enough that the tile the human's bowman is on is in that radius.

	- If a knight is used to sneak up behind (or on the side) a ranged group and do a hit and run.*)
	RANGED_NOT_ATTACKED = 0;
	RANGED_ATTACKED_BY_NONRANGED = 2;
	RANGED_ATTACKED_BY_RANGED = 10;


Var
	recentlyAttackTiles, defenseLocationTiles, recentlyChasedOffSingleLeaders, humAICompAL: Array of Integer;
	attacks: Array of Array of Array of Integer;
	groupTypes: Array of TKMGroupType;
	currentlyTaggedGroups: String;
	neutralTiles: Array of String;


//---------
//Utilities
//---------

	Procedure AL__Append_I(var arr: Array of Integer; value: Integer);
	begin //Append Integer to an array.
		SetLength(arr, Length(arr) + 1);
		arr[High(arr)] := value;
	end;

	Function AL__Position_I(arr: Array of Integer; element: Integer): Integer;
	var	i: Integer; //Return index of first occurrence of an integer in an array.
	begin
		For i := Low(arr) to High(arr) do begin
			If arr[i] = element Then begin
				result := i;
				Exit;
			end;
		end;
		Result := -1; //The element is not in ar.
	end;

	Procedure AL__Remove_I_2D(var arr: Array of Array of Integer; position: Integer);
	begin //To remove an array from an array for when order doesnt matter.
		arr[position] := arr[High(arr)];
		SetLength(arr, Length(arr) - 1);
	end;

	Function AL__Split_I(str, delimeter: String): Array of Integer;
	var i: Integer; //NOTE:  This is tailored to the input.  (Not a generalized Split_I!
	begin
		SetLength(Result, (Length(str) + 1) / 5);
		For i := 0 to High(Result) do Result[i] := StrToInt(Copy(str, 5 * i + 1, 4));
	end;

	Function KaM_Distance(x1, y1, x2, y2: Integer): Single;
	begin //https://github.com/Kromster80/kam_remake/blob/b199128f2ce826302a7626463018bfb88cfde032/src/KM_Points.pas#L616
		If Abs(x1 - x2) > Abs(y1 - y2)
		Then Result := Abs(x1 - x2) + Abs(y1 - y2) * 0.41
		Else Result := Abs(y1 - y2) + Abs(x1 - x2) * 0.41;
	end;

	Function Squared_Distance(x1, y1, x2, y2: Integer): Single;
	begin
		Result := (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
	end;


//----------
//KaM States
//----------
	Function AL__Unit_Is_Ranged(unitID: Integer): Boolean;
	begin //Used instead of S.GroupTypeEx = gtRanged because of situations with unitID does not exist.
		Result := Pos('|' + IntToStr(S.UnitType(unitID)) + '|', '|17|18|25|') > 0;
	end;

	Function AL__Unit_Is_Dead(unitID: Integer): Boolean;
	begin
		Result := unitID < 0;
	end;

	Function AL__Group_Is_Dead(groupID: Integer): Boolean;
	begin
		Result := (groupID > 0) And (S.GroupTypeEx(groupID) = gtNone);
	end;

	Function AL__Get_All_Players(findAIPlayers: Boolean): Array of Integer;
	var p: Integer;
	begin //Pass True to get an array of AI Players and False to get an array of human players.
		For p := 0 to High(playersToConsiderAL) do
			If S.PlayerEnabled(playersToConsiderAL[p])
			And (S.PlayerIsAI(playersToConsiderAL[p]) = findAIPlayers)
			Then AL__Append_I(Result, playersToConsiderAL[p]);
	end;

	Function In_Defense_Radius(tileX, tileY, groupID, groupMember: Integer; defenseRadius: Single): Boolean;
	begin
		Result := KaM_Distance(tileX, tileY,
					S.UnitPositionX(S.GroupMember(groupID, groupMember)),
					S.UnitPositionY(S.GroupMember(groupID, groupMember))
				  ) <= defenseRadius;
	end;

	Function In_Firing_Radius(tileX, tileY, groupID, groupMember: Integer): Boolean;
	begin
		Result := Squared_Distance(tileX, tileY,
					S.UnitPositionX(S.GroupMember(groupID, groupMember)),
					S.UnitPositionY(S.GroupMember(groupID, groupMember))
				  ) < 121;
	end;

	Function Around_Unit_HitBox(tileX, tileY, groupID, groupMember: Integer): Boolean;
	begin
		Result := Squared_Distance(tileX, tileY,
					S.UnitPositionX(S.GroupMember(groupID, groupMember)),
					S.UnitPositionY(S.GroupMember(groupID, groupMember))
				  ) < 4;
	end;

	Function Player_Get_All_Defending_Groups(attackedPlayer, tileX, tileY, rangedAttackStatus: Integer): Array of Integer;
	var i, g, player, indexx: Integer; potentialDefendingGroups, defendingGroups: Array of Integer; defense: TKMDefencePositionInfo; groupDefendsXY: Boolean;
	begin //Doesn't consider if human attacks another human in which the AI defends.(When would that be the case anyway?)
	//The index of tile (x,y) in allMapTiles is defined by:  (S.MapWidth - 1) * (y - 1) + x.
		indexx := mapWidth * (tileY - 1) + tileX;
		If (defPosInfoArray[indexx] = '') Then Exit;
		potentialDefendingGroups := AL__Split_I(defPosInfoArray[indexx], ',');
		While i < Length(potentialDefendingGroups) do begin
			player := potentialDefendingGroups[i] - 1;
			indexx := potentialDefendingGroups[i + 1] - 1;
			If (S.PlayerAllianceCheck(player, attackedPlayer))
			And (indexx < S.StatAIDefencePositionsCount(player))
			Then begin
				defense := S.AIDefencePositionGetByIndex(player, indexx);
				If (defense.groupID > 0) //group ID exists
				And (S.GroupTypeEx(defense.groupID) <> gtNone) //How can a groupID exist and the group doesn't?
			//Prevent scheduled attackNearestUnit waves from being disrupted.
			//(To ensure that groups will not be halted multiple times in a short period of time.)
				And (Pos('|' + IntToStr(defense.groupID) + '|', currentlyTaggedGroups) = 0) //Group isn't tagged already.
				Then begin
					groupDefendsXY := False;
					If S.GroupTypeEx(defense.groupID) = gtRanged Then begin
						Case rangedAttackStatus of
							RANGED_ATTACKED_BY_NONRANGED: begin
								If In_Defense_Radius(tileX, tileY, defense.groupID, 0, defense.radius) Then begin
									groupDefendsXY := True;
								end Else begin(*
								Check to see if (tileX, tileY) is one of the 8 tiles around each and every unit in the ranged group.
								- Note that if two AI ranged groups are side by side, and one gets hit by a knight, both may be halted as a result (depending on where the knight was).*)
									For g := 0 to S.GroupMemberCount(defense.groupID) - 1 do
										If Around_Unit_HitBox(tileX, tileY, defense.groupID, g) Then begin
											groupDefendsXY := True;
											Break;
										end;
								end;
							end;
							RANGED_ATTACKED_BY_RANGED: begin
								If In_Defense_Radius(tileX, tileY, defense.groupID, 0, defense.radius) Then begin
									groupDefendsXY := True;
								end Else begin(*
								If human ranged shot AI ranged AND the current group being scanned is ranged, consider every member in the group (not just the leader), because any one of them could have been shot at.
								- In addition, consider their firing radius (instead of their defense radius).*)
									For g := 0 to S.GroupMemberCount(defense.groupID) - 1 do
										If In_Firing_Radius(tileX, tileY, defense.groupID, g) Then begin
											groupDefendsXY := True;
											Break;
										end;
								end;
							end;
							RANGED_NOT_ATTACKED: begin
								If In_Defense_Radius(tileX, tileY, defense.groupID, 0, defense.radius)
								Then groupDefendsXY := True;
							end;
						end;
					end Else begin
						If In_Defense_Radius(tileX, tileY, defense.groupID, 0, defense.radius)
						Then groupDefendsXY := True;
					end;
					If groupDefendsXY Then begin
						SetLength(defendingGroups, Length(defendingGroups) + 3);
						defendingGroups[High(defendingGroups) - 2] := defense.groupID;
						defendingGroups[High(defendingGroups) - 1] := defense.x;
						defendingGroups[High(defendingGroups) - 0] := defense.y;
						currentlyTaggedGroups := currentlyTaggedGroups + '|' + IntToStr(defense.groupID) + '|';
						// A.Log('(' + IntToStr(tileX) + ', ' + IntToStr(tileY) + ')' + ' is within player ' +
						// IntToStr(player + 1) + '''s ' + AL__GroupType_String(defense.groupType) + ' group''s defense radius of ' +
						// IntToStr(defense.radius) + '.  Group location: (' + IntToStr(defense.x) + ', ' + IntToStr(defense.y) + ').');
					end;
				end;
			end;
			i := i + 2;
		end;
		Result := defendingGroups;
	end;


//----------------
//Main Subroutines
//----------------
	Function Tile_XY_Was_Recently_Attacked(x, y: Integer): Boolean;
	var	i: Integer;
	begin
		While i <= High(recentlyAttackTiles) - 2 do begin
			If (recentlyAttackTiles[i] = x) And (recentlyAttackTiles[i + 1] = y) Then begin
				Result := True;
				Exit;
			end;
			i := i + 3;
		end;
	end;

	Function Tile_Is_Neutral(attackerUnitID: Integer): Boolean;
	var i: Integer;
	begin //Either if tile has been marked neutral OR if tile has not yet been marked as neutral but is in fact neutral.
		For i := 0 to High(neutralTiles) do
			If Pos('|' + IntToStr(S.UnitPositionX(attackerUnitID)) + ',' + IntToStr(S.UnitPositionY(attackerUnitID)) + '|', neutralTiles[i]) > 0 Then begin
				Result := True;
				Exit;
			end;
	end;

	//Don't continue to recheck if a tile is in at least one AI group's defense radius!
	//But this assumes that new defense locations are not made during the script!
	Procedure Mark_Off_Neutral_Tile(attackerUnitID: Integer);
	begin
		If Tile_Is_Neutral(attackerUnitID) Then Exit;
		If Length(neutralTiles[High(neutralTiles)]) + 9 > 65535 Then SetLength(neutralTiles, Length(neutralTiles) + 1);
		neutralTiles[High(neutralTiles)] := neutralTiles[High(neutralTiles)] + '|' + IntToStr(S.UnitPositionX(attackerUnitID)) + ',' + IntToStr(S.UnitPositionY(attackerUnitID)) + '|';
	end;

	Function Get_Preferred_Available_Group(arr: Array of Integer; groupID: Integer): TKMGroupType;
	var i, groupType: Integer; groupTypePriority: Array of TKMGroupType;
	begin
		Case S.GroupTypeEx(groupID) of
			gtRanged: groupTypePriority := [gtRanged, gtMounted, gtMelee, gtAntiHorse];
			gtMelee: groupTypePriority := [gtMounted, gtMelee, gtAntiHorse, gtRanged];
			gtAntiHorse: groupTypePriority := [gtMelee, gtAntiHorse, gtMounted, gtRanged];
			gtMounted: groupTypePriority := [gtAntiHorse, gtMounted, gtMelee, gtRanged];
		end;
		For groupType := 0 to 3 do begin
			i := 0;
			While i <= Length(arr) - 2 do begin
				If S.GroupTypeEx(arr[i]) = groupTypePriority[groupType] Then begin
					Result := groupTypePriority[groupType];
					Exit;
				end;
				i := i + 3;
			end;
		end;
		Result := gtNone;
	end;

	Function Continue_To_Monitor_Decoys_And_Pursuing_Groups(humanDecoyGroupID, pursuingGroupID: Integer): Boolean;
	begin
		If AL__Group_Is_Dead(humanDecoyGroupID) Or AL__Group_Is_Dead(pursuingGroupID) //Either group is dead
		Then Result := True
		Else If S.GroupOrder(pursuingGroupID) = goAttackUnit Then Result := True; //Both groups are alive,
	end;

	Procedure Mark_Off_Human_Ranged_Decoy_And_AI_Pursuing_Group;
	var i: Integer;
	begin //(humanDecoyGroupID, aiPursuingGroupID),(..,..),...
		While i < Length(recentlyChasedOffSingleLeaders) - 1 do begin
			If Continue_To_Monitor_Decoys_And_Pursuing_Groups(recentlyChasedOffSingleLeaders[i], recentlyChasedOffSingleLeaders[i + 1]) = False Then begin
				recentlyChasedOffSingleLeaders[i] := recentlyChasedOffSingleLeaders[High(recentlyChasedOffSingleLeaders) - 1];
				recentlyChasedOffSingleLeaders[i + 1] := recentlyChasedOffSingleLeaders[High(recentlyChasedOffSingleLeaders)];
				SetLength(recentlyChasedOffSingleLeaders, Length(recentlyChasedOffSingleLeaders) - 2);
			end;
			i := i + 2;
		end;
	end;

	Function GroupLeader_Is_On_A_Defense_Location_XY(groupID: Integer): Boolean;
	var i, unitX, unitY: Integer;
	begin
		unitX := S.UnitPositionX(S.GroupMember(groupID, 0));
		unitY := S.UnitPositionY(S.GroupMember(groupID, 0));
		While i <= High(defenseLocationTiles) - 1 do begin //Radius of Sqrt(18) ensures 3 tiles all around defense tile.
			If Squared_Distance(defenseLocationTiles[i], defenseLocationTiles[i + 1], unitX, unitY) <= 18 Then begin
				Result := True;
				Exit;
			end;
			i := i + 2;
		end;
	end;

Const
	HOUSE_ = -6;
	UNIT_ = -7;

	Procedure Record_Attack(targetUnitOrHouseID, attackerUnitID, typeAttacked, aiAttackedHuman, haltGroupsImmediately: Integer);
	var i, indexx, rangedAttackStatus: Integer; attack, groupIDsToHalt: Array of Integer; preferedGroupType: TKMGroupType; groupChosen: Boolean;
	begin
		SetLength(attack, GROUP_IDS_TO_HALT_ + 1);
		//The "ATTACKER" is considered the human (regarding defense radii), no matter what.
		//The "TARGETED PLAYER" is considered the AI (...).
		If aiAttackedHuman = YES Then begin //If AI attacks a human player's SOLDIER ONLY!
		//(This procedure will not be called if the AI attacks a human player's villager or house.)

		//Coordinates are wherever the human player's unit was in contact with the enemy.
			attack[X__] := S.UnitPositionX(targetUnitOrHouseID);
			attack[Y__] := S.UnitPositionY(targetUnitOrHouseID);

		//No need to record if human player's bowmen gets killed before his arrow hits a tower, for example.
			If attack[X__] = -1 Then Exit;
			If Tile_XY_Was_Recently_Attacked(attack[X__], attack[Y__]) Then Exit; //Major Optimization Line!
			attack[ATTACKER_UNIT_ID_] := targetUnitOrHouseID;
			attack[ATTACKER_GROUP_ID_] := S.UnitsGroup(targetUnitOrHouseID);
			attack[ATTACKER_PLAYER_] := S.UnitOwner(targetUnitOrHouseID);
			attack[TARGETED_PLAYER_] := S.UnitOwner(attackerUnitID);
			attack[TARGETED_GROUP_ID_] := S.UnitsGroup(attackerUnitID);
			attack[TARGETED_UNIT_TYPE_] := S.UnitType(attackerUnitID);
		end Else begin //Human Attacked AI's villager, soldier, or house.

		//Coordinates are STILL wherever the human player's unit was in contact with the enemy.
			attack[X__] := S.UnitPositionX(attackerUnitID);
			attack[Y__] := S.UnitPositionY(attackerUnitID);

		//No need to record if AI's villager dies before a recording can be made.
			If attack[X__] = -1 Then Exit;
			If Tile_XY_Was_Recently_Attacked(attack[X__], attack[Y__]) Then Exit; //Major Optimization Line!
			attack[ATTACKER_UNIT_ID_] := attackerUnitID;
			attack[ATTACKER_GROUP_ID_] := S.UnitsGroup(attackerUnitID);
			attack[ATTACKER_PLAYER_] := S.UnitOwner(attackerUnitID);
			If typeAttacked = UNIT_ Then begin
				attack[TARGETED_UNIT_TYPE_] := S.UnitType(targetUnitOrHouseID);
				attack[TARGETED_PLAYER_] := S.UnitOwner(targetUnitOrHouseID);
				If attack[TARGETED_UNIT_TYPE_] > 13 Then begin //Only if unit is a soldier.
					attack[TARGETED_GROUP_ID_] := S.UnitsGroup(targetUnitOrHouseID)
					If AL__Unit_Is_Ranged(targetUnitOrHouseID) Then begin //AI ranged,
						If AL__Unit_Is_Ranged(attackerUnitID)
						Then rangedAttackStatus := RANGED_ATTACKED_BY_RANGED  //was attacked by human ranged,
						Else rangedAttackStatus := RANGED_ATTACKED_BY_NONRANGED;//was attacked by human non-ranged,
					end;
				end;
			end Else begin
				attack[TYPE_ATTACKED_] := HOUSE_;
				attack[TARGETED_PLAYER_] := S.HouseOwner(targetUnitOrHouseID);
			end;
		end;

		groupIDsToHalt := Player_Get_All_Defending_Groups(attack[TARGETED_PLAYER_], attack[X__], attack[Y__], rangedAttackStatus);

	//If Human player is using very few units (maybe even just a single leader) to lure,
		If haltGroupsImmediately = YES Then begin
			indexx := AL__Position_I(recentlyChasedOffSingleLeaders, attack[ATTACKER_GROUP_ID_]);
			If indexx > -1 Then begin //If human ranged group is already being tracked,
				If Continue_To_Monitor_Decoys_And_Pursuing_Groups(recentlyChasedOffSingleLeaders[indexx], recentlyChasedOffSingleLeaders[indexx + 1]) Then begin
					groupChosen := True;
					preferedGroupType := S.GroupTypeEx(recentlyChasedOffSingleLeaders[indexx + 1]);

			 //Get one group to go after him (or them).
				end Else preferedGroupType := Get_Preferred_Available_Group(groupIDsToHalt, attack[ATTACKER_GROUP_ID_]);

			//Get one group to go after him (or them).
			end Else preferedGroupType := Get_Preferred_Available_Group(groupIDsToHalt, attack[ATTACKER_GROUP_ID_]);

			If preferedGroupType = gtNone Then Exit; //There are no available groups in range.  Exit.

			While i <= Length(groupIDsToHalt) - 2 do begin
				If (S.GroupTypeEx(groupIDsToHalt[i]) = preferedGroupType) And (groupChosen = False)	Then begin
				//Keep track of the human archer decoy and the AI pursing group.
					SetLength(recentlyChasedOffSingleLeaders, Length(recentlyChasedOffSingleLeaders) + 2);
					recentlyChasedOffSingleLeaders[High(recentlyChasedOffSingleLeaders) - 1] := attack[ATTACKER_GROUP_ID_];
					recentlyChasedOffSingleLeaders[High(recentlyChasedOffSingleLeaders)] := groupIDsToHalt[i];
					i := i + 3;
					groupChosen := True;
				end	Else begin
				//Halt all other groups IF they are on their defense locations.
					If GroupLeader_Is_On_A_Defense_Location_XY(groupIDsToHalt[i]) Then begin
						A.GroupOrderHalt(groupIDsToHalt[i]);

					//Remove them from the currently tagged groups list so that they can potentially be
					//recorded in the next attack, as they will NOT be recorded in this attack's recording.
						currentlyTaggedGroups := U.StringReplace(currentlyTaggedGroups, '|' + IntToStr(groupIDsToHalt[i]) + '|', '', True, False);
						groupIDsToHalt[i] := groupIDsToHalt[High(groupIDsToHalt) - 2];
						groupIDsToHalt[i + 1] := groupIDsToHalt[High(groupIDsToHalt) - 1];
						groupIDsToHalt[i + 2] := groupIDsToHalt[High(groupIDsToHalt)];
						SetLength(groupIDsToHalt, Length(groupIDsToHalt) - 3);
					end Else i := i + 3;
				end;
			end;

		//If group has already been chosen the following will be the case.
		//Do NOT mark off the tile as neutral!
			If Length(groupIDsToHalt) = 0 Then Exit;
		end;

		attack[GROUP_IDS_TO_HALT_] := Length(groupIDsToHalt);
		If (attack[GROUP_IDS_TO_HALT_] = 0) Then begin
			If aiAttackedHuman = YES
			Then Mark_Off_Neutral_Tile(targetUnitOrHouseID)
			Else Mark_Off_Neutral_Tile(attackerUnitID);
			Exit; //Don't record the attack if it happened outside of all AI groups' defense circles.
		end;

		SetLength(attack, GROUP_IDS_TO_HALT_ + 1 + attack[GROUP_IDS_TO_HALT_]);
		For i := 0 to High(groupIDsToHalt) do attack[i + GROUP_IDS_TO_HALT_ + 1] := groupIDsToHalt[i];

		attack[TIME__] := S.GameTime;

		If haltGroupsImmediately = NO Then begin
			SetLength(recentlyAttackTiles, Length(recentlyAttackTiles) + 3);
			recentlyAttackTiles[High(recentlyAttackTiles) - 2] := attack[X__];
			recentlyAttackTiles[High(recentlyAttackTiles) - 1] := attack[Y__];
			recentlyAttackTiles[High(recentlyAttackTiles)] := attack[TIME__];
		end;

		SetLength(attacks[attack[TARGETED_PLAYER_]], Length(attacks[attack[TARGETED_PLAYER_]]) + 1);
		attacks[attack[TARGETED_PLAYER_]][High(attacks[attack[TARGETED_PLAYER_]])] := attack;
	end;
		Procedure AL__OnUnitAttacked(targetUnitID, attackerUnitID: Integer);
		var minimumGroupSize, humanGroupID, aiGroupID, aiAttackedHuman, haltGroupsImmediately: Integer;
		begin
		//Don't ask why.  (It's a mystery!)
			If (attackerUnitID < 1) Or (targetUnitID < 1) Then Exit;

		//If tower recruit attacked,
			If S.UnitType(attackerUnitID) = 13 Then Exit; //Don't record.

		//If player's own ranged units' arrows damaged its own unit, GET OUTTA HERE!
			If S.UnitOwner(attackerUnitID) = S.UnitOwner(targetUnitID) Then Exit;

		//Group won't exist even when a soldier does in at least one situation.
		//For example, in the case when a unit WITHOUT A FLAG is the first to come out of a barracks and the barracks is being "choked" https://youtu.be/Jau7nBztYZo?t=2779.
		//Or perhaps if a group's leader gets killed.
			humanGroupID := S.UnitsGroup(attackerUnitID);
			aiGroupID := S.UnitsGroup(targetUnitID);
			If (humanGroupID < 1) Or (aiGroupID < 1) Then Exit;

		//For all other cases,
			Case humAICompAL[S.UnitOwner(targetUnitID)] - humAICompAL[S.UnitOwner(attackerUnitID)] of
			//If (a human player got attacked by a human player) or (AI player got attacked by AI player),
				0: begin
					Exit; //Don't record
				end;

			//If an AI player got attacked by a human player,
				1: begin
				//If a human player's soldier attacked, see how large its group is.
					If AL__Unit_Is_Ranged(attackerUnitID)
					Then minimumGroupSize := RANGED_DECOY_COUNT + 1
					Else minimumGroupSize := NONRANGED_DECOY_COUNT + 1;

				//If human player's group is small enough to consider having just ONE AI group pursue it,
					If (S.GroupMemberCount(humanGroupID) < minimumGroupSize) Then begin

					//If AI Unit is a solder (this check is to prevent error messages from inquiring about a "villager's group"),
						If S.UnitType(targetUnitID) > 13 Then begin

						//If group was on their defense location right before the human player's offense,
						//chances are that surrounding groups were on THEIR defense locations as well.
							If GroupLeader_Is_On_A_Defense_Location_XY(aiGroupID)
							And (S.GroupOrder(aiGroupID) = goAttackUnit)
							Then haltGroupsImmediately := YES;
						end Else haltGroupsImmediately := YES; //If AI villager was attacked.
					end;
				end;

			//If a human player got attacked by an AI player.
				-1: begin
				//Attacked by AI ranged unit,
					If AL__Unit_Is_Ranged(attackerUnitID) Then begin

					//And if it's the opposite case to "if AI ranged unit is on his way to attack a human player's soldier",
					//That is, the opposite of the condition:
					//((S.UnitType(targetUnitID) > 13) And (S.WarriorInFight(attackerUnitID, False) = False))
					//That, if (AI ranged is attacking human player's villager) OR (AI ranged is already firing human player's soldier),
						If (S.UnitType(targetUnitID) < 14) Or S.WarriorInFight(attackerUnitID, False)

					//That's not going to trigger the AI groups who defend tiles to go after the human player's unit, no matter what.
					//Clearly the ranged group has not just been lured (so other defending groups will not be lured either).
						Then Exit; //Don't record

				//Attacked by AI non-ranged unit.
					end Else begin

					//Don't record if a human player's villager got attacked by an AI's non-ranged unit
						If S.UnitType(targetUnitID) < 14 Then Exit;

					 //If there's actual contact, the true tile of "offense" is the one the human player's unit is on.
						If S.WarriorInFight(attackerUnitID, False) Then aiAttackedHuman := YES;
					end;
				end;
			end;

		//If the tile has already been determined to not be in any defense radius, don't record.
			If Tile_Is_Neutral(targetUnitID) Then Exit;

		//Attempt to record attack if gotten this far.
			Record_Attack(targetUnitID, attackerUnitID, UNIT_, aiAttackedHuman, haltGroupsImmediately);

		end; {$EVENT evtUnitAttacked:AL__OnUnitAttacked}

		Procedure AL__OnHouseDamaged(targetHouseID, attackerUnitID: Integer);
		var humanGroupID, haltGroupsImmediately: Integer;
		begin //As you can see from comments below, there is no support for when AI attacks AI house!
		//Don't ask why.  (It's a mystery!)
			If (targetHouseID < 1) Or (attackerUnitID < 1) Then Exit;

		//If player's own ranged units' arrows damaged its own house, GET OUTTA HERE!
			If S.UnitOwner(attackerUnitID) = S.HouseOwner(targetHouseID) Then Exit;
			humanGroupID := S.UnitsGroup(attackerUnitID);
			If humanGroupID < 1 Then Exit;

		//If AI player's house was attacked by a human player's unit
			If (humAICompAL[S.HouseOwner(targetHouseID)] - humAICompAL[S.UnitOwner(attackerUnitID)] = 1)
			And (Tile_Is_Neutral(attackerUnitID) = False) //Tile is potentially in defense radius territory.
			Then begin
				If AL__Unit_Is_Ranged(attackerUnitID) Then begin
					If (S.GroupMemberCount(humanGroupID) < RANGED_DECOY_COUNT + 1)
					Then haltGroupsImmediately := YES;
				end Else begin
					If (S.GroupMemberCount(humanGroupID) < NONRANGED_DECOY_COUNT + 1)
					Then haltGroupsImmediately := YES;
				end;
				Record_Attack(targetHouseID, attackerUnitID, HOUSE_, NO, haltGroupsImmediately);
			end;
		end; {$EVENT evtHouseDamaged:AL__OnHouseDamaged}

	Function Attacker_Moved_Far_Enough_Away(player: Integer; attack: Array of Integer; randI: Single; group: Integer): Boolean;
	var closestHouseID: Integer;
	begin
		If AL__Unit_Is_Dead(attack[ATTACKER_UNIT_ID_]) Then begin
			Result := True; //Prevents a lot of log file error messages!
			Exit;
		end;
		If KaM_Distance(
			S.UnitPositionX(S.GroupMember(attack[group], 0)),
			S.UnitPositionY(S.GroupMember(attack[group], 0)),
			attack[group + 1], //Defense Location x-coordinate.
			attack[group + 2] //Defense Location y-coordinate.
		) > weights[DEFENSE_POSITION_DISTANCE_][player] Then begin
			Result := True;
			Exit;
		end;
		If attack[TYPE_ATTACKED_] = UNIT_ Then begin
			If attack[TARGETED_UNIT_TYPE_] < 14 Then begin //If unit WAS a villager.
				closestHouseID := S.ClosestHouse(attack[TARGETED_PLAYER_], attack[X__], attack[Y__], -1);
				If closestHouseID > 0 Then begin
					Result := KaM_Distance(
						S.HousePositionX(closestHouseID),
						S.HousePositionY(closestHouseID),
						S.UnitPositionX(attack[ATTACKER_UNIT_ID_]),
						S.UnitPositionY(attack[ATTACKER_UNIT_ID_])
					) >= weights[VILLAGER_DISTANCE_][player] * randI;
				end;
			end	Else begin //A soldier was attacked.
				If AL__Group_Is_Dead(attack[TARGETED_GROUP_ID_]) Then begin
					//If the group he attacked is DEAD, consider the tile (x,y) where the attack happened.
					Result := KaM_Distance(
						attack[X__],
						attack[Y__],
						S.UnitPositionX(attack[ATTACKER_UNIT_ID_]),
						S.UnitPositionY(attack[ATTACKER_UNIT_ID_])
					) >= weights[UNIT_DISTANCE_][player] * randI;
				end	Else begin
					//If the group he attacked is still alive, consider its LEADER's location.
					Result := KaM_Distance(
						S.UnitPositionX(S.GroupMember(attack[TARGETED_GROUP_ID_], 0)),
						S.UnitPositionY(S.GroupMember(attack[TARGETED_GROUP_ID_], 0)),
						S.UnitPositionX(attack[ATTACKER_UNIT_ID_]),
						S.UnitPositionY(attack[ATTACKER_UNIT_ID_])
					) >= weights[UNIT_DISTANCE_][player] * randI;
				end;
			end;
		end	Else begin
		//A building/house was attacked.  Consider where the tile (x,y) were the attack happened.
			Result := KaM_Distance(
				attack[X__],
				attack[Y__],
				S.UnitPositionX(attack[ATTACKER_UNIT_ID_]),
				S.UnitPositionY(attack[ATTACKER_UNIT_ID_])
			) >= weights[BUILDING_DISTANCE_][player] * randI;
		end;
	end;

	Function Link_Before_Dead_Is_Being_Attempted(attack: Array of Integer): Boolean;
	begin
		Result := AL__Unit_Is_Dead(attack[ATTACKER_UNIT_ID_])
		And (AL__Group_Is_Dead(attack[ATTACKER_GROUP_ID_]) = False)
		And (S.GroupInFight(attack[ATTACKER_GROUP_ID_], False) = False);
	end;

	Procedure AL__Remove_Group(player, attack, group: Integer);
	begin
		currentlyTaggedGroups := U.StringReplace(currentlyTaggedGroups, '|' + IntToStr(attacks[player][attack][group]) + '|', '', True, False);
		attacks[player][attack][group] := -1;
	end;

	Procedure Halt_Group_If_Applicable(player, attack, group: Integer);
	begin
		If S.GroupOrder(attacks[player][attack][group]) = goAttackHouse
		Then AL__Remove_Group(player, attack, group) //Don't halt a group attacking a house (no matter what).
		Else begin
		//Halting a group in a fight may cause lag.
		//But it also causes volunterabilites to the LBD trick.
		//So we don't halt them when they are in a fight!  (We save the halt for a time when they have finished fighting... should at least one of the members in the group still be alive at that time.)
			If (S.GroupInFight(attacks[player][attack][group], False) = False) Then begin
				A.GroupOrderHalt(attacks[player][attack][group]);
				AL__Remove_Group(player, attack, group);
			end
		end;
	end;

	Function All_Groups_Have_Been_Halted(groupsToBeHalted: Array of Integer; firstGroup, lastGroup: Integer): Boolean;
	var i: Integer;
	begin
	 //groupsToBeHalted is of the form: [groupID, x, y, groupID, x, y, ...] (created at the end of Function Player_Get_All_Defending_Groups)
		i := firstGroup;
		While i <= lastGroup do begin
			If (groupsToBeHalted[i] <> -1) Then Exit;
			i := i + 3;
		end;
		Result := True;
	end;

	Procedure Halt_Groups;
	var player, attack, group, groupType, firstGroup, lastGroup, randI: Integer;
	begin
		For player := aiPlayersAL[0] to aiPlayersAL[High(aiPlayersAL)] do begin
			For attack := Low(attacks[player]) to High(attacks[player]) do begin
				firstGroup := GROUP_IDS_TO_HALT_ + 1;
				lastGroup := High(attacks[player][attack]) - 2;
				If All_Groups_Have_Been_Halted(attacks[player][attack], firstGroup, lastGroup)
				Or (Link_Before_Dead_Is_Being_Attempted(attacks[player][attack]) And (weights[LINK_BEFORE_DEAD_ALLOWED_][player] = YES))
				Then AL__Remove_I_2D(attacks[player], attack) //Remove attack
				Else begin
					group := firstGroup;
					While group <= lastGroup do begin
						If attacks[player][attack][group] <> -1 Then begin
							If AL__Group_Is_Dead(attacks[player][attack][group])
							Then AL__Remove_Group(player, attack, group)
							Else begin
								For groupType := 0 to 3 do begin
									If S.GroupTypeEx(attacks[player][attack][group]) = groupTypes[groupType] Then begin
										If weights[RANDOM_DISTANCE_MULTIPLIER_][player] = YES Then randI := U.RandomRangeI(1, 2) Else randI := 1;
										If Attacker_Moved_Far_Enough_Away(player, attacks[player][attack], randI, group) Then begin
											If weights[RANDOM_DELAY_MULTIPLIER_][player] = YES Then randI := U.RandomRangeI(1, 3) Else randI := 1;
											If (weights[RESET_TIMER_][player]  = YES) And (attacks[player][attack][TIME_WAS_RESET_] = NO) Then begin
												attacks[player][attack][TIME__] := S.GameTime + weights[groupType][player] * 10 * randI;
												attacks[player][attack][TIME_WAS_RESET_] := 1;
											end	Else begin
												If S.GameTime >= attacks[player][attack][TIME__] + weights[groupType][player] * 10 * randI Then begin
													Halt_Group_If_Applicable(player, attack, group);
													Break; //Don't search for the group type (again). It's already been found!
												end;
											end;
										end;
									end;
								end;
							end;
						end;
						group := group + 3;
					end;
				end;
			end;
		end;
	end;

	(*We don't want any given tile (x,y) that an attack was recorded to remain
	 ignored for too long, because if a new attack is made on that same tile,
	 all AI groups that respond to THAT attack will be vulnerable to lure.

	 Let them get reconsidered again after 10 seconds (100 ticks).
	 *)
	Procedure Remove_Recently_Attacked_Tiles;
	var i, newLow, gameTime: Integer; arr: Array of Integer;
	begin //recentlyAttackTiles is a 1D array of the form: [x, y, gameTime, x, y, gameTime, ...].
		gameTime := S.GameTime;
		While i <= High(recentlyAttackTiles) - 2 do
			If gameTime - recentlyAttackTiles[i + 2] >= 100 Then i := i + 3 Else Break;
		If i = 0 Then Exit; //If not enough time has passed to remove any recently attacked tiles, don't continue.
		newLow := i;
		SetLength(arr, Length(recentlyAttackTiles) - newLow);
		For i := newLow to High(recentlyAttackTiles) do arr[i - newLow] := recentlyAttackTiles[i];
		recentlyAttackTiles := arr;
	end;

	Procedure Halt_All_Ranged_Defender_Groups_Not_Recorded;
	var i, j: Integer; defense: TKMDefencePositionInfo;
	begin
		For i := 0 to High(aiPlayersAL) do begin
			If S.PlayerDefeated(aiPlayersAL[i]) = False Then
				For j := 0 to High(defenderDefensePositions[aiPlayersAL[i]]) do begin
					If (defenderDefensePositions[aiPlayersAL[i]][j] < S.StatAIDefencePositionsCount(aiPlayersAL[i])) Then begin
						defense := S.AIDefencePositionGetByIndex(aiPlayersAL[i], defenderDefensePositions[aiPlayersAL[i]][j]);
						If (defense.groupID > 0) //Group exists.
						And (defense.groupType <> gtNone) //Yeah, again, but I don't know why.
						And (Pos('|' + IntToStr(defense.groupID) + '|', currentlyTaggedGroups) = 0) //Group isn't tagged.
						Then A.GroupOrderHalt(defense.groupID);
					end;
				end;
		end;
	end;

	Procedure AL__OnTick;
	begin
		If S.GameTime Mod 10 = 0 Then begin
			Halt_Groups;
			Mark_Off_Human_Ranged_Decoy_And_AI_Pursuing_Group;
			If S.GameTime Mod 100 = 0 Then begin
				Remove_Recently_Attacked_Tiles;
				Halt_All_Ranged_Defender_Groups_Not_Recorded;
			end;
		end;
	end; {$EVENT evtTick:AL__OnTick}

	Procedure AL__Remove_AutoAttackRange;
	var i: Integer;
	begin
		For i := 0 to High(aiPlayersAL) do A.AIAutoAttackRange(aiPlayersAL[i], 1);
	end;

	Procedure Get_All_Starting_Defense_Location_Tiles;
	var i, j, len, previousLen: Integer; defense: TKMDefencePositionInfo;
	begin(*
	Get all put all defense tiles XY into an array so that we can check to see that if any AI group's leader is on one of those tiles (or tiles within a certain radius distance from those tiles... due to fast moving units like mounted), then HALT all groups.  (This is for when 1 bowmen trigger them to move.)*)
		SetLength(defenderDefensePositions, S.LocationCount);
		For i := Low(aiPlayersAL) to High(aiPlayersAL) do begin
			len := len + 2 * S.StatAIDefencePositionsCount(aiPlayersAL[i]);
			SetLength(defenseLocationTiles, len);
			j := 0;
			While j <= len - previousLen - 1 do begin
				defense := S.AIDefencePositionGetByIndex(aiPlayersAL[i], j / 2);
				defenseLocationTiles[previousLen + j] := defense.x;
				defenseLocationTiles[previousLen + j + 1] := defense.y;
				If (defense.PositionType = dtFrontLine)//If it's a defender group
				Then AL__Append_I(defenderDefensePositions[aiPlayersAL[i]] , j / 2);
				j := j + 2;
			end;
			previousLen := len;
		end;
	end;

	//A procedure to optimize AL__OnUnitAttacked and AL__OnHouseDamaged.
	//(Elliminates the need to check if player is AI or not.)
	Procedure AL__Make_HumanPlayer_AIPlayer_Comparison_Array;
	var p: Integer;
	begin
		SetLength(humAICompAL, S.LocationCount);
		For p := 0 to S.LocationCount - 1 do
			If S.PlayerEnabled(p) And S.PlayerISAI(p) Then humAICompAL[p] := 1;
	end;

	Procedure AL__OnMissionStart;
	begin
		SetLength(neutralTiles, 1);
		mapWidth := S.MapWidth - 1;

	//For the main halting procedure.
		SetLength(attacks, S.LocationCount);
		groupTypes := [gtRanged, gtAntiHorse, gtMelee, gtMounted];

	//For user settings,
		If REMOVE_AUTO_ATTACK_RANGE = YES Then AL__Remove_AutoAttackRange;
		AL__Initialize_CONSTANTS;

	 //This allows us to halt all defender groups periodically.
		Get_All_Starting_Defense_Location_Tiles;

	//A procedure in the supporting script, "zzcmDefencePositionInfoArray.script" generated by "Defence Position Info Array Updater.hta" (after you put that HTA in the map folder and double click on it).
		Get_Starting_Defense_Position_Info;

	//playersToConsiderAL is in zzcmDefencePositionInfoArray.script.  These are the players (both human and AI) that were NOT excluded by the user from the .hta application.  We determine which are human and AI and assign them to their respective arrays below.
		aiPlayersAL := AL__Get_All_Players(True);
		humanPlayersAL := AL__Get_All_Players(False);

	//A procedure to optimize AL__OnUnitAttacked and AL__OnHouseDamaged.
		AL__Make_HumanPlayer_AIPlayer_Comparison_Array;
	end; {$EVENT evtMissionStart:AL__OnMissionStart}