{$IFNDEF zzcmAntiLure}{$DEFINE zzcmAntiLure} Const DEF = -1; YES = 1; NO = 0; //<---PLEASE DO NOT CHANGE THESE!

(*"Anti-Lure" . . . A script by cmowla (June 10, 2023). [Last updated on November 8, 2024] (v3.9b ... Minimal Lag version)
- Tested on r15122.
- Special thanks to DontTalk and Klaas (KW) for helping me test this during development!


(If you experience any problems, don't be shy to contact my on Discord about it, AS I DON'T INTEND TO MAKE ANOTHER UPDATE TO THIS SCRIPT UNLESS THERE IS AN ISSUE.)

_________________________________________________________________________________________
How to Use:
[1] Put "{$Include zzcmAntiLure.script}" (without quotes) at the beginning of the map's script.
[2] Change the values of the constants below to have the desired effect.
	- All CONSTANTS below except for REMOVE_AUTO_ATTACK_RANGE and RANGED_DECOY_COUNT (which apply to ALL players) represent the default for ALL players.  But further down are tables for players 1 - 30 in which each player can have a custom value for each.  (The more care you as the map maker take in tailoring these to the different AI players to your map, the better AntiLure will work!)
[3] This (minimal lag) version of this script requires a supporting scripted named "zzcmDefencePositionInfoArray.script".
	- You must create this script by running the external App that I wrote which autogenerates it.
	- The app is named "Defence Position Info Array Updater v1.0.hta" and should have been in the folder for which you downloaded this script from.  (Version # will naturally change if I make any changes to it, of course.)
	- Simply put this app IN THE MAP FOLDER, double click on the app to run, input the map's Width and then the map's height (follow the prompts).  After a few seconds (at most), a script named "zzcmDefencePositionInfoArray.script" should be created in the map folder, and it's ready to use!
	- IMPORTANT NOTE:  Any time you make a change to the AI's defense positions (in ANY WAY), you need to rerun this app to recreate/update "zzcmDefencePositionInfoArray.script".  Very important!

_________________________________________________________________________________________
Script Limitations:

This script cannot save AI groups from lure if:

(1) Defense locations are not set.
	- It specifically searches if an attack was made on a tile (x,y) that IS IN A DEFENSE CIRCLE.
	- This limitation can be removed, but for almost every GOOD map that I'm aware of, defense locations will be set at the start of the game.  (It will be a rare occurrence... on GOOD MAPS ... that this is actually a limitation.)

(2) The AI player defends a human player and the human player is being attacked or if it's AI against AI.
	- This script is only designed to prevent lure for human assaults on AI and AI assaults on humans (both in AI territory).
	- However, it's not going to be a common occurrence when this type of situation happens (human AI allys getting abused by human opponents to humans).

(3) New defense locations are made during the game which previous defense locations did NOT defend.
	- It's not necessarily a deal-breaker, but IT IS A VULNERABILITY (AI groups stationed at those new defense locations will be completely vulnerable to lure as they are by default).
	- This limitation can be removed, but it exists to remove a significant amount of lag.

(4) Any non-ranged group's autoattack range is > 1.
	- This script prevents lure from these groups should a nearby unit or house be hit.  But getting within close proximity to them (while they're idle) will result in them following the decoy FOREVER (as usual).
	- Simple fix is to make all non-ranged unit groups autoattack range = 1.
	- The first constant below allows you to do this automatically (with this script).

(5) There are two versions of this script.  This one requires a LARGE script file named "zzcmDefencePositionInfoArray.script".  (A file autogenerated by an external HTA application I wrote which creates a map of how every tile is defended by which groups from which player.)
	- This version has MUCH LESS LAG than the one without it, but this version will occasionally miss groups who are "on their way" to a defense position (whether it be from rotating or that the group was just trained).
	- If the tile in which the attack happened is not in the LEADER's defense radius (where we define "defense radius" here to mean that we assume that every tile he walks on is the defense position . . . and therefore imagine that the defense radius of his defense position is redrawn every step he takes), then the group will not get triggered by the attack (from the game itself).
	- The big change is making Player_Get_All_Defending_Groups(...) MUCH LESS TAXING!
	- Lastly, loading in all of the data in the LARGE script file ("zzcmDefencePositionInfoArray.script") will delay the game's start by MAYBE a second or 2 (at most), but after that, there should be NO VISIBLE LAG for the rest of the game.

_________________________________________________________________________________________
SETTINGS:


Regarding (4) from above, you can simply set the following to YES, and it will take care of that vulnerability.*)
REMOVE_AUTO_ATTACK_RANGE = YES;



(*_______________________________________________________________________________________
 Number of bowman, crossbowmen, or rogues to tell AI to only send 1 group after it.  (Halt all others immediately.)
- Set to 0 if you want to "disable" this feature.*)
RANGED_DECOY_COUNT = 1;



(*_______________________________________________________________________________________
 Number of non-ranged (melee, mounted, anti-horse) to tell AI to only send 1 group after it.  (Halt all others immediately.)
- Set to 0 if you want to "disable" this feature.  Separate from ranged because mounted units are easier to use to lure, for example.*)
NONRANGED_DECOY_COUNT = 1;


(*_______________________________________________________________________________________
Set all 4 of these = 0 if you don't want to return to their posts based on time delay.
- You are allowed to set different delays (in seconds) for each of the 4 group types.
- Due to mounted units faster speed, it may be ideal to set a longer delay for them to pursue.  (If these values are chosen with care, they can make it back to their posts at the same time as the foot soldiers.)
- Due to ranged units' vulnerability to flanking, it may be ideal to set a shorter delay for them to pursue.
- (It may be helpful to know that mounted units move about 1.66 times as fast as foot soldiers when setting the times.)
- All values represent SECONDS.*)
RANGED_DELAY = 5;
ANTIHORSE_DELAY = 7;
MELEE_DELAY = 7;
MOUNTED_DELAY = 12;


(*In addition to setting the above delays, if RANDOM_DELAY_MULTIPLIER = YES, then a random number (between 1 and 3) will be multiplied by those amounts upon every check.*)
RANDOM_DELAY_MULTIPLIER = NO;


(*_______________________________________________________________________________________
For the cases when an AI unit/group is attacked in some way...OR when an human player's unit is attacked by AI in AI territory (where "AI territory" means wherever defense locations are).

This is the minimum distance the attacking unit/decoy must be away from the leader of the group that he attacked (before those groups will go home... regardless of the time delay set, should the distance imply a longer delay).

This comes in handy to compensate for attempting to abuse the time delays, because even if the time delays HAVE EXPIRED, if the decoy is still within range, the AI will pursue him.  (This effectively makes the AI aggressive to discourage human players from attempting to lure out multiple groups from the outskirts of its village.)

But should the duration of time that is set for them to return to their posts has expired once the attacking unit/decoy is UNIT_DISTANCE tiles or more away, the groups will all (at the same time) return to their posts . . . should RESET_TIMER be set to NO.

Setting UNIT_DISTANCE to 0 will effectively DISABLE this feature, but if considered, note that:

- This script considers the SPECIFIC UNIT of the group that attacked for this distance, not the closest unit in the group when it comes time to check (should the decoy either be a part of a group at the time of the offense OR the other units joined to the decoy after the offense).

- Should the group that the human player's decoy (most likely a bowman) attacks IS DEAD by the time it's time to check the distance that he's away from the group, then the distance he is (now) away from the tile (x,y) where he made the offense will used (rather than the distance away from the group that he attacked... because it's dead, so we cannot "find where it is").*)
UNIT_DISTANCE = 0;


(*_______________________________________________________________________________________
For the cases when a unit/group attacks an AI player's building/house.

Until the attacking unit/decoy is BUILDING_DISTANCE away from where he was when he attacked the building, the AI groups will continue to pursue the decoy.

- This is not necessarily the location (x,y) that the building's door is in the map editor... just the actual tile (x,y) where he made the offense.

- This effectively handles the case when the house happens to get destroyed during the pursuit... that is, we don't look to where the location of the house is that he attacked when it's time to check!  We instead look to this tile (x,y) where he attacked the house from.

(Just like for UNIT_DISTANCE, this comes in handy to compensate for attempting to abuse the time delays.  And this effectively makes the AI much more aggressive to discourage sneaking into villages!)

But should the duration of time that is set for them to return to their posts has expired once the attacking unit/decoy is BUILDING_DISTANCE tiles or more away from the location (x,y) where he attacked the building/house, the groups will all (at the same time) return to their posts . . . should RESET_TIMER be set to NO.

But if RESET_TIMER is YES, then once the decoy is BUILDING_DISTANCE away from the point (x,y) when he attacked a building, the group types will return to their posts in the order that is determined by the times in which each group type is set (by you) to return.*)
BUILDING_DISTANCE = 5;


(*_______________________________________________________________________________________
See the last 2 bullet points under the comments above BUILDING_DISTANCE.)*)
RESET_TIMER = YES;


(*_______________________________________________________________________________________
Should an AI's villager (of any kind, including recruits) be attacked, if not set to 0 (which would effectively disable this feature), this represents the minimum distance the human player decoy must be away from the closest building/house (that is owned by the AI player that he attacked) from the tile (x,y) from which he attacked the villager.

- The villager most likely will die from the attack, and thus we cannot search for his current position MOST OF THE TIME when it's time to check if the human player's decoy is far enough away.*)
VILLAGER_DISTANCE = 0;


(*_______________________________________________________________________________________
Just like there is a random multiplier for delays, there is one for distances.

- If set to YES, it will be applied (and it will be applied to every check), but only a random integer between 1 and 2 (not between 1 and 3).

- It applies to UNIT, BUILDING, and VILLAGER distances.*)
RANDOM_DISTANCE_MULTIPLIER = NO;


(*_______________________________________________________________________________________
If set to a distance < the other constants will naturally force, this is the MAXIMUM allowed distance a group can be from its defense position.
- Set to 255 (largest map dimension) to effectively disable this additional means to halt groups after a certain period of time, since it potentially WILL interfere with the timings.*)
DEFENSE_POSITION_DISTANCE = 255;


(*_______________________________________________________________________________________
If YES, then my (cmowla's) link-before-dead (LBD) trick will still work, despite all other types of lure not working. But if NO, then my link-before-dead will NOT work!*)
LINK_BEFORE_DEAD_IS_ALLOWED = NO;



(*_______________________________________________________________________________________
Below are tables for most of the constants above.
- They allow you to set different values for different players!
- You only need to set values for the specific AI players that are on the map.  (If players don't exist, it doesn't matter.)
- Currently this script assumes that there are up to 30 players on a map (human and AI).  But if in the future there is more, you will need to manually edit the Case switch statements (add in more player numbers)!*)


Function Ranged_Delays(player: Integer): Integer;
var rangedDelay: Integer; begin Case player of //Put an integer (for seconds) or def (for Default)
	1: rangedDelay := def;	11: rangedDelay := def;	21: rangedDelay := def;
	2: rangedDelay := def;	12: rangedDelay := def;	22: rangedDelay := def;
	3: rangedDelay := def;	13: rangedDelay := def;	23: rangedDelay := def;
	4: rangedDelay := def;	14: rangedDelay := def;	24: rangedDelay := def;
	5: rangedDelay := def;	15: rangedDelay := def;	25: rangedDelay := def;
	6: rangedDelay := def;	16: rangedDelay := def;	26: rangedDelay := def;
	7: rangedDelay := def;	17: rangedDelay := def;	27: rangedDelay := def;
	8: rangedDelay := def;	18: rangedDelay := def;	28: rangedDelay := def;
	9: rangedDelay := def;	19: rangedDelay := def;	29: rangedDelay := def;
	10: rangedDelay := def;	20: rangedDelay := def;	30: rangedDelay := def;
end;Result:=rangedDelay;end;


Function AntiHorse_Delays(player: Integer): Integer;
var antiHorseDelay: Integer; begin Case player of //Put an integer (for seconds) or def (for Default)
	1: antiHorseDelay := def;	11: antiHorseDelay := def;	21: antiHorseDelay := def;
	2: antiHorseDelay := def;	12: antiHorseDelay := def;	22: antiHorseDelay := def;
	3: antiHorseDelay := def;	13: antiHorseDelay := def;	23: antiHorseDelay := def;
	4: antiHorseDelay := def;	14: antiHorseDelay := def;	24: antiHorseDelay := def;
	5: antiHorseDelay := def;	15: antiHorseDelay := def;	25: antiHorseDelay := def;
	6: antiHorseDelay := def;	16: antiHorseDelay := def;	26: antiHorseDelay := def;
	7: antiHorseDelay := def;	17: antiHorseDelay := def;	27: antiHorseDelay := def;
	8: antiHorseDelay := def;	18: antiHorseDelay := def;	28: antiHorseDelay := def;
	9: antiHorseDelay := def;	19: antiHorseDelay := def;	29: antiHorseDelay := def;
	10: antiHorseDelay := def;	20: antiHorseDelay := def;	30: antiHorseDelay := def;
end;Result:=antiHorseDelay;end;


Function Melee_Delays(player: Integer): Integer;
var meleeDelay: Integer; begin Case player of //Put an integer (for seconds) or def (for Default)
	1: meleeDelay := def;	11: meleeDelay := def;	21: meleeDelay := def;
	2: meleeDelay := def;	12: meleeDelay := def;	22: meleeDelay := def;
	3: meleeDelay := def;	13: meleeDelay := def;	23: meleeDelay := def;
	4: meleeDelay := def;	14: meleeDelay := def;	24: meleeDelay := def;
	5: meleeDelay := def;	15: meleeDelay := def;	25: meleeDelay := def;
	6: meleeDelay := def;	16: meleeDelay := def;	26: meleeDelay := def;
	7: meleeDelay := def;	17: meleeDelay := def;	27: meleeDelay := def;
	8: meleeDelay := def;	18: meleeDelay := def;	28: meleeDelay := def;
	9: meleeDelay := def;	19: meleeDelay := def;	29: meleeDelay := def;
	10: meleeDelay := def;	20: meleeDelay := def;	30: meleeDelay := def;
end;Result:=meleeDelay;end;


Function Mounted_Delays(player: Integer): Integer;
var mountedDelay: Integer; begin Case player of //Put an integer (for seconds) or def (for Default)
	1: mountedDelay := def;		11: mountedDelay := def;	21: mountedDelay := def;
	2: mountedDelay := def;		12: mountedDelay := def;	22: mountedDelay := def;
	3: mountedDelay := def;		13: mountedDelay := def;	23: mountedDelay := def;
	4: mountedDelay := def;		14: mountedDelay := def;	24: mountedDelay := def;
	5: mountedDelay := def;		15: mountedDelay := def;	25: mountedDelay := def;
	6: mountedDelay := def;		16: mountedDelay := def;	26: mountedDelay := def;
	7: mountedDelay := def;		17: mountedDelay := def;	27: mountedDelay := def;
	8: mountedDelay := def;		18: mountedDelay := def;	28: mountedDelay := def;
	9: mountedDelay := def;		19: mountedDelay := def;	29: mountedDelay := def;
	10: mountedDelay := def;	20: mountedDelay := def;	30: mountedDelay := def;
end;Result:=mountedDelay;end;


Function Unit_Distances(player: Integer): Integer;
var unitDistance: Integer; begin Case player of //Put an integer (for tiles) or def (for Default)
	1: unitDistance := def;		11: unitDistance := def;	21: unitDistance := def;
	2: unitDistance := def;		12: unitDistance := def;	22: unitDistance := def;
	3: unitDistance := def;		13: unitDistance := def;	23: unitDistance := def;
	4: unitDistance := def;		14: unitDistance := def;	24: unitDistance := def;
	5: unitDistance := def;		15: unitDistance := def;	25: unitDistance := def;
	6: unitDistance := def;		16: unitDistance := def;	26: unitDistance := def;
	7: unitDistance := def;		17: unitDistance := def;	27: unitDistance := def;
	8: unitDistance := def;		18: unitDistance := def;	28: unitDistance := def;
	9: unitDistance := def;		19: unitDistance := def;	29: unitDistance := def;
	10: unitDistance := def;	20: unitDistance := def;	30: unitDistance := def;
end;Result:=unitDistance;end;


Function Building_Distances(player: Integer): Integer;
var buildingDistance: Integer; begin Case player of //Put an integer (for tiles) or def (for Default)
	1: buildingDistance := def;		11: buildingDistance := def;	21: buildingDistance := def;
	2: buildingDistance := def;		12: buildingDistance := def;	22: buildingDistance := def;
	3: buildingDistance := def;		13: buildingDistance := def;	23: buildingDistance := def;
	4: buildingDistance := def;		14: buildingDistance := def;	24: buildingDistance := def;
	5: buildingDistance := def;		15: buildingDistance := def;	25: buildingDistance := def;
	6: buildingDistance := def;		16: buildingDistance := def;	26: buildingDistance := def;
	7: buildingDistance := def;		17: buildingDistance := def;	27: buildingDistance := def;
	8: buildingDistance := def;		18: buildingDistance := def;	28: buildingDistance := def;
	9: buildingDistance := def;		19: buildingDistance := def;	29: buildingDistance := def;
	10: buildingDistance := def;	20: buildingDistance := def;	30: buildingDistance := def;
end;Result:=buildingDistance;end;


Function Villager_Distances(player: Integer): Integer;
var villagerDistance: Integer; begin Case player of //Put an integer (for tiles) or def (for Default)
	1: villagerDistance := def;		11: villagerDistance := def;	21: villagerDistance := def;
	2: villagerDistance := def;		12: villagerDistance := def;	22: villagerDistance := def;
	3: villagerDistance := def;		13: villagerDistance := def;	23: villagerDistance := def;
	4: villagerDistance := def;		14: villagerDistance := def;	24: villagerDistance := def;
	5: villagerDistance := def;		15: villagerDistance := def;	25: villagerDistance := def;
	6: villagerDistance := def;		16: villagerDistance := def;	26: villagerDistance := def;
	7: villagerDistance := def;		17: villagerDistance := def;	27: villagerDistance := def;
	8: villagerDistance := def;		18: villagerDistance := def;	28: villagerDistance := def;
	9: villagerDistance := def;		19: villagerDistance := def;	29: villagerDistance := def;
	10: villagerDistance := def;	20: villagerDistance := def;	30: villagerDistance := def;
end;Result:=villagerDistance;end;


Function Defense_Position_Distances(player: Integer): Integer;
var defPosDistance: Integer; begin Case player of //Put an integer (for tiles) or def (for Default)
	1: defPosDistance := def;	11: defPosDistance := def;	21: defPosDistance := def;
	2: defPosDistance := def;	12: defPosDistance := def;	22: defPosDistance := def;
	3: defPosDistance := def;	13: defPosDistance := def;	23: defPosDistance := def;
	4: defPosDistance := def;	14: defPosDistance := def;	24: defPosDistance := def;
	5: defPosDistance := def;	15: defPosDistance := def;	25: defPosDistance := def;
	6: defPosDistance := def;	16: defPosDistance := def;	26: defPosDistance := def;
	7: defPosDistance := def;	17: defPosDistance := def;	27: defPosDistance := def;
	8: defPosDistance := def;	18: defPosDistance := def;	28: defPosDistance := def;
	9: defPosDistance := def;	19: defPosDistance := def;	29: defPosDistance := def;
	10: defPosDistance := def;	20: defPosDistance := def;	30: defPosDistance := def;
end;Result:=defPosDistance;end;


Function Random_Delay_Multipliers(player: Integer): Integer;
var randDelayMult: Integer; begin Case player of //Type yes, no, or def (for Default)
	1: randDelayMult := def;	11: randDelayMult := def;	21: randDelayMult := def;
	2: randDelayMult := def;	12: randDelayMult := def;	22: randDelayMult := def;
	3: randDelayMult := def;	13: randDelayMult := def;	23: randDelayMult := def;
	4: randDelayMult := def;	14: randDelayMult := def;	24: randDelayMult := def;
	5: randDelayMult := def;	15: randDelayMult := def;	25: randDelayMult := def;
	6: randDelayMult := def;	16: randDelayMult := def;	26: randDelayMult := def;
	7: randDelayMult := def;	17: randDelayMult := def;	27: randDelayMult := def;
	8: randDelayMult := def;	18: randDelayMult := def;	28: randDelayMult := def;
	9: randDelayMult := def;	19: randDelayMult := def;	29: randDelayMult := def;
	10: randDelayMult := def;	20: randDelayMult := def;	30: randDelayMult := def;
end;Result:=randDelayMult;end;


Function Random_Distance_Multipliers(player: Integer): Integer;
var randDistMult: Integer; begin Case player of //Type yes, no, or def (for Default)
	1: randDistMult := def;		11: randDistMult := def;	21: randDistMult := def;
	2: randDistMult := def;		12: randDistMult := def;	22: randDistMult := def;
	3: randDistMult := def;		13: randDistMult := def;	23: randDistMult := def;
	4: randDistMult := def;		14: randDistMult := def;	24: randDistMult := def;
	5: randDistMult := def;		15: randDistMult := def;	25: randDistMult := def;
	6: randDistMult := def;		16: randDistMult := def;	26: randDistMult := def;
	7: randDistMult := def;		17: randDistMult := def;	27: randDistMult := def;
	8: randDistMult := def;		18: randDistMult := def;	28: randDistMult := def;
	9: randDistMult := def;		19: randDistMult := def;	29: randDistMult := def;
	10: randDistMult := def;	20: randDistMult := def;	30: randDistMult := def;
end;Result:=randDistMult;end;


Function Reset_Timers(player: Integer): Integer;
var resetTimer: Integer; begin Case player of //Type yes, no, or def (for Default)
	1: resetTimer := def;	11: resetTimer := def;	21: resetTimer := def;
	2: resetTimer := def;	12: resetTimer := def;	22: resetTimer := def;
	3: resetTimer := def;	13: resetTimer := def;	23: resetTimer := def;
	4: resetTimer := def;	14: resetTimer := def;	24: resetTimer := def;
	5: resetTimer := def;	15: resetTimer := def;	25: resetTimer := def;
	6: resetTimer := def;	16: resetTimer := def;	26: resetTimer := def;
	7: resetTimer := def;	17: resetTimer := def;	27: resetTimer := def;
	8: resetTimer := def;	18: resetTimer := def;	28: resetTimer := def;
	9: resetTimer := def;	19: resetTimer := def;	29: resetTimer := def;
	10: resetTimer := def;	20: resetTimer := def;	30: resetTimer := def;
end;Result:=resetTimer;end;


Function Link_Before_Deads_Allowed(player: Integer): Integer;
var linkBeforeDead: Integer; begin Case player of //Type yes, no, or def (for Default)
	1: linkBeforeDead := def;	11: linkBeforeDead := def;	21: linkBeforeDead := def;
	2: linkBeforeDead := def;	12: linkBeforeDead := def;	22: linkBeforeDead := def;
	3: linkBeforeDead := def;	13: linkBeforeDead := def;	23: linkBeforeDead := def;
	4: linkBeforeDead := def;	14: linkBeforeDead := def;	24: linkBeforeDead := def;
	5: linkBeforeDead := def;	15: linkBeforeDead := def;	25: linkBeforeDead := def;
	6: linkBeforeDead := def;	16: linkBeforeDead := def;	26: linkBeforeDead := def;
	7: linkBeforeDead := def;	17: linkBeforeDead := def;	27: linkBeforeDead := def;
	8: linkBeforeDead := def;	18: linkBeforeDead := def;	28: linkBeforeDead := def;
	9: linkBeforeDead := def;	19: linkBeforeDead := def;	29: linkBeforeDead := def;
	10: linkBeforeDead := def;	20: linkBeforeDead := def;	30: linkBeforeDead := def;
end;Result:=linkBeforeDead;end;



(*-------------------------------------------
|____________CODE STARTS NOW________________|
--------------------------------------------*)
Var aiPlayers, humanPlayers: Array of Integer;

//---------------------
//Debugging Subroutines
//---------------------
	Function GroupType_String(groupType: TKMGroupType): String;
	begin //Called in Player_Get_All_Defending_Groups
		Case groupType of
			gtMelee : Result := 'Melee';
			gtAntiHorse : Result := 'Anti-Horse';
			gtRanged : Result := 'Ranged';
			gtMounted : Result := 'Mounted';
		end;
	end;

	Procedure Print(str: String);
	begin
		A.Log(str);
	end;

	Procedure Print_I(num: Integer);
	begin
		A.Log(IntToStr(num));
	end;

	Procedure Print_B(bool: Boolean);
	begin
		If bool Then A.Log('True') Else A.Log('False');
	end;

	Procedure Print_Array(arr: Array of Integer);
	var i: Integer; str: String;
	begin
		For i := Low(arr) to High(arr) do begin
			str := str + IntToStr(arr[i]);
			If i < High(arr) Then str := str + '|';
		end;
		A.Log(str);
	end;

	Procedure Print_Array_2D(arr: Array of Array of Integer);
	var i, j: Integer; str: String;
	begin
		For i := Low(arr) to High(arr) do begin
			str := '';
			For j := Low(arr[i]) to High(arr[i]) do str := str + IntToStr(arr[i][j]) + ',';
			A.Log(' ');
			A.Log(Copy(str, 1, Length(str) - 1));
		end;
	end;

	Procedure Quit;
	var i: Integer;
	begin //It's good to put "Quit; Exit;" as a line in any given procedure/function when using this.
		For i := Low(aiPlayers) to High(aiPlayers) do Actions.PlayerDefeat(aiplayers[i]);
		For i := Low(humanPlayers) to High(humanPlayers) do Actions.PlayerDefeat(humanPlayers[i]);
	end;


//----------------------------------------
{$Include zzcmDefencePositionInfoArray.script}
Var
	rangedDelays, antiHorseDelays, meleeDelays, mountedDelays,
	unitDistances, buildingDistances, villagerDistances, defensePositionDistances,
	randomDelayMultipliers, randomDistanceMultipliers, resetTimers, linkBeforeDeads: Array of Integer;
	weights, defenderDefensePositions: Array of Array of Integer;
	defPosInfoArray: Array of String; //|player#, index#, player#, index#,...|player#, index#, player#, index#,...|
	mapWidth: Integer;

Const
	RANGED_DELAY_ = 0;
	ANTIHORSE_DELAY_ = 1;
	MELEE_DELAY_ = 2;
	MOUNTED_DELAY_ = 3;
	UNIT_DISTANCE_ = 4;
	BUILDING_DISTANCE_ = 5;
	VILLAGER_DISTANCE_ = 6;
	DEFENSE_POSITION_DISTANCE_ = 7;
	RANDOM_DELAY_MULTIPLIER_ = 8;
	RANDOM_DISTANCE_MULTIPLIER_ = 9;
	RESET_TIMER_ = 10;
	LINK_BEFORE_DEAD_ALLOWED_ = 11;


Procedure Initialize_CONSTANTS;
var i, locCnt: Integer;
begin
	locCnt := S.LocationCount;

	SetLength(rangedDelays, locCnt);
	For i := 0 to locCnt - 1 do
		If Ranged_Delays(i + 1) = def
		Then rangedDelays[i] := RANGED_DELAY
		Else rangedDelays[i] := Ranged_Delays(i + 1);

	SetLength(antiHorseDelays, locCnt);
	For i := 0 to locCnt - 1 do
		If AntiHorse_Delays(i + 1) = def
		Then antiHorseDelays[i] := ANTIHORSE_DELAY
		Else antiHorseDelays[i] := AntiHorse_Delays(i + 1);

	SetLength(meleeDelays, locCnt);
	For i := 0 to locCnt - 1 do
		If Melee_Delays(i + 1) = def
		Then meleeDelays[i] := MELEE_DELAY
		Else meleeDelays[i] := Melee_Delays(i + 1);

	SetLength(mountedDelays, locCnt);
	For i := 0 to locCnt - 1 do
		If Mounted_Delays(i + 1) = def
		Then mountedDelays[i] := MOUNTED_DELAY
		Else mountedDelays[i] := Mounted_Delays(i + 1);

	SetLength(unitDistances, locCnt);
	For i := 0 to locCnt - 1 do
		If Unit_Distances(i + 1) = def
		Then unitDistances[i] := UNIT_DISTANCE
		Else unitDistances[i] := Unit_Distances(i + 1);

	SetLength(buildingDistances, locCnt);
	For i := 0 to locCnt - 1 do
		If Building_Distances(i + 1) = def
		Then buildingDistances[i] := BUILDING_DISTANCE
		Else buildingDistances[i] := Building_Distances(i + 1);

	SetLength(villagerDistances, locCnt);
	For i := 0 to locCnt - 1 do
		If Villager_Distances(i + 1) = def
		Then villagerDistances[i] := VILLAGER_DISTANCE
		Else villagerDistances[i] := Villager_Distances(i + 1);

	SetLength(defensePositionDistances, locCnt);
	For i := 0 to locCnt - 1 do
		If Defense_Position_Distances(i + 1) = def
		Then defensePositionDistances[i] := DEFENSE_POSITION_DISTANCE
		Else defensePositionDistances[i] := Defense_Position_Distances(i + 1);

	SetLength(randomDelayMultipliers, locCnt);
	For i := 0 to locCnt - 1 do
		If Random_Delay_Multipliers(i + 1) = def
		Then randomDelayMultipliers[i] := RANDOM_DELAY_MULTIPLIER
		Else randomDelayMultipliers[i] := Random_Delay_Multipliers(i + 1);

	SetLength(randomDistanceMultipliers, locCnt);
	For i := 0 to locCnt - 1 do
		If Random_Distance_Multipliers(i + 1) = def
		Then randomDistanceMultipliers[i] := RANDOM_DISTANCE_MULTIPLIER
		Else randomDistanceMultipliers[i] := Random_Distance_Multipliers(i + 1);

	SetLength(resetTimers, locCnt);
	For i := 0 to locCnt - 1 do
		If Reset_Timers(i + 1) = def
		Then resetTimers[i] := RESET_TIMER
		Else resetTimers[i] := Reset_Timers(i + 1);

	SetLength(linkBeforeDeads, locCnt);
	For i := 0 to locCnt - 1 do
		If Link_Before_Deads_Allowed(i + 1) = def
		Then linkBeforeDeads[i] := LINK_BEFORE_DEAD_IS_ALLOWED
		Else linkBeforeDeads[i] := Link_Before_Deads_Allowed(i + 1);

	SetLength(weights, 12);
	weights[RANGED_DELAY_] := rangedDelays;
	weights[ANTIHORSE_DELAY_] := antiHorseDelays;
	weights[MELEE_DELAY_] := meleeDelays;
	weights[MOUNTED_DELAY_] := mountedDelays;
	weights[UNIT_DISTANCE_] := unitDistances;
	weights[BUILDING_DISTANCE_] := buildingDistances;
	weights[VILLAGER_DISTANCE_] := villagerDistances;
	weights[DEFENSE_POSITION_DISTANCE_] := defensePositionDistances;
	weights[RANDOM_DELAY_MULTIPLIER_] := randomDelayMultipliers;
	weights[RANDOM_DISTANCE_MULTIPLIER_] := randomDistanceMultipliers;
	weights[RESET_TIMER_] := resetTimers;
	weights[LINK_BEFORE_DEAD_ALLOWED_] := linkBeforeDeads;
end;


(*------------------------
Recorded attack properties
-------------------------*)
Const
	X__ = 0;
	Y__ = 1;
	TIME__ = 2;
	TYPE_ATTACKED_ = 3; //0 if unit, 1 if house.
	TARGETED_PLAYER_ = 4;//Player that was attacked
	TARGETED_GROUP_ID_ = 5;//ID of the group that was attacked.  Needed to determine if unit dies.
	TARGETED_UNIT_TYPE_ = 6;//Unit type constant.  Needed to distinguish between soldier and villager.
	ATTACKER_UNIT_ID_ = 7; //Needed to track his current position and if he died (for LBD trick).
	ATTACKER_GROUP_ID_ = 8; //Needed to track if his group is still alive after he dies (for LBD trick).
	ATTACKER_PLAYER_ = 9; //Needed to allow scheduled attackNearestUnit attack waves.
	TIME_WAS_RESET_ = 10;

	(*An argument which tells how many AI groups who respond to an attack.

	- The remaining arguments of the array are the group IDs of all AI groups who respond to an attack the (x,y) where the offense took place happened in their defense circle/radius, each followed by their defense.x and defense.y.

	- They are either groups owned by the AI player that was attacked or its allies' groups.

	- If either all members in the group die OR the group has been halted/told to return to their post, -1 will be written in place of the groupID number.*)
	GROUP_IDS_TO_HALT_ = 11;

//------------------------
(*Parameters for attacked AI ranged units:
	They are very much needed to prevent ranged from being lured.  (DO NOT CHANGE THESE!  These are a part of the code!)
	Some situations include:

	- If a human player uses a bowmen to fire at a ranged group from the side, where the defense radius of the ranged group is not large enough that the tile the human's bowman is on is in that radius.

	- If a knight is used to sneak up behind (or on the side) a ranged group and do a hit and run.*)
	RANGED_NOT_ATTACKED = 0;
	RANGED_ATTACKED_BY_NONRANGED = 2;
	RANGED_ATTACKED_BY_RANGED = 10;


Var
	attacks: Array of Array of Array of Integer;
	recentlyAttackTiles, defenseLocationTiles, recentlyChasedOffSingleLeaders: Array of Integer;
	groupTypes: Array of TKMGroupType;
	currentlyTaggedGroups: String;
	neutralTiles: Array of String;


//---------
//Utilities
//---------
	Function Append_Int(arr: Array of Integer; value: Integer): Array of Integer;
	begin //Append Integer to an array.
		SetLength(arr, Length(arr) + 1);
		arr[High(arr)] := value;
		Result := arr;
	end;

	Function Position_Int(arr: Array of Integer; element: Integer): Integer;
	var	i: Integer; //Return index of first occurrence of an integer in an array.
	begin
		For i := Low(arr) to High(arr) do begin
			If arr[i] = element Then begin
				result := i;
				Exit;
			end;
		end;
		Result := -1; //The element is not in ar.
	end;

	Function Remove_Int_2D(arr: Array of Array of Integer; position: Integer): Array of Array of Integer;
	begin //To remove an array from an array for when order doesnt matter.
		arr[position] := arr[High(arr)];
		SetLength(arr, Length(arr) - 1);
		Result := arr;
	end;

	Function Substring(str: String; start, finish: Integer): String;
	begin
		Result := Copy(str, start, finish - start + 1);
	end;

	Function Split_I(str, delimeter: String): Array of Integer;
	var i, occurrence: Integer; arr: Array of Integer;
	begin
		SetLength(arr, Length(str));
		occurrence := Pos(delimeter, str);
		While occurrence > 0 do begin
			arr[i] := StrToInt64(Substring(str, 1, occurrence - 1));
			str := Substring(str, occurrence + 1, Length(str));
			occurrence := Pos(delimeter, str);
			i := i + 1;
		end;
		arr[i] := StrToInt64(str);
		SetLength(arr, i + 1);
		Result := arr;
	end;

	Function KaM_Distance(x1, y1, x2, y2: Integer): Single;
	begin //https://github.com/Kromster80/kam_remake/blob/b199128f2ce826302a7626463018bfb88cfde032/src/KM_Points.pas#L616
		If Abs(x1 - x2) > Abs(y1 - y2)
		Then Result := Abs(x1 - x2) + Abs(y1 - y2) * 0.41
		Else Result := Abs(y1 - y2) + Abs(x1 - x2) * 0.41;
	end;

	Function Squared_Distance(x1, y1, x2, y2: Integer): Single;
	begin
		Result := (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
	end;

	Function Floor(num: Single): Integer;
	begin
		If (num < 0) And (-num - Int(-num) > 0) Then Result := -Trunc(-num) - 1 Else Result := Trunc(num);
	end;

	Function Modulous(a, b: Single): Integer;
	begin
		Result := Trunc(a - b * Floor(a / b));
	end;
//----------
//KaM States
//----------
	Function Unit_Is_Dead(unitID: Integer): Boolean;
	begin
		Result := S.UnitTypeEx(unitID) = utNone;
	end;

	Function Unit_Is_Ranged(unitID: Integer): Boolean;
	begin //Used instead of S.GroupTypeEx = gtRanged because of situations with unitID does not exist.
		Result := U.ArrayHasElementI(S.UnitType(unitID), [17,18,25]);
	end;

	Function Get_All_Players(findAIPlayers: Boolean): Array of Integer;
	var playerNumber: Integer;
	begin //Pass True to get an array of aiPlayers and False to get an array of human players.
		For playerNumber := 0 to S.LocationCount - 1 do
			If S.PlayerEnabled(playerNumber) Then
				If S.PlayerIsAI(playerNumber) = findAIPlayers
				Then Result := Append_Int(Result, playerNumber);
	end;

	Function In_Defense_Radius(tileX, tileY, groupID, groupMember: Integer; defenseRadius: Single): Boolean;
	begin
		Result := KaM_Distance(tileX, tileY,
					S.UnitPositionX(S.GroupMember(groupID, groupMember)),
					S.UnitPositionY(S.GroupMember(groupID, groupMember))
				  ) <= defenseRadius;
	end;

	Function In_Firing_Radius(tileX, tileY, groupID, groupMember: Integer): Boolean;
	begin
		Result := Squared_Distance(tileX, tileY,
					S.UnitPositionX(S.GroupMember(groupID, groupMember)),
					S.UnitPositionY(S.GroupMember(groupID, groupMember))
				  ) < 121;
	end;

	Function Around_Unit_HitBox(tileX, tileY, groupID, groupMember: Integer): Boolean;
	begin
		Result := Squared_Distance(tileX, tileY,
					S.UnitPositionX(S.GroupMember(groupID, groupMember)),
					S.UnitPositionY(S.GroupMember(groupID, groupMember))
				  ) < 4;
	end;

	Function Player_Get_All_Defending_Groups(attackedPlayer, tileX, tileY, rangedAttackStatus: Integer): Array of Integer;
	var i, g, player, indexx: Integer; potentialDefendingGroups, defendingGroups: Array of Integer; defense: TKMDefencePositionInfo; groupDefendsXY: Boolean;
	begin //Doesn't consider if human attacks another human in which the AI defends.(When would that be the case anyway?)
		//The index of tile (x,y) in allMapTiles is defined by:  (S.MapWidth - 1) * (y - 1) + x
		//x = Modulous(k, mapWidth) and y = -Floor(-k / mapWidth).
		indexx := mapWidth * (tileY - 1) + tileX;
		If (defPosInfoArray[indexx] = '') Then Exit;
		potentialDefendingGroups := Split_I(defPosInfoArray[indexx], ',');
		While i < Length(potentialDefendingGroups) do begin
			player := potentialDefendingGroups[i] - 1;
			indexx := potentialDefendingGroups[i + 1] - 1;
			If S.PlayerAllianceCheck(player, attackedPlayer) Then begin
				defense := S.AIDefencePositionGetByIndex(player, indexx);
				If (defense.groupID > 0) //group ID exists
				And (S.GroupTypeEx(defense.groupID) <> gtNone) //How can a groupID exist and the group doesn't?
				//Prevent scheduled attackNearestUnit waves from being disrupted.
				//(To ensure that groups will not be halted multiple times in a short period of time.)
				And (Pos('|' + IntToStr(defense.groupID) + '|', currentlyTaggedGroups) = 0) //Group isn't tagged already.
				Then begin
					groupDefendsXY := False;
					If S.GroupTypeEx(defense.groupID) = gtRanged Then begin
						Case rangedAttackStatus of
							RANGED_ATTACKED_BY_NONRANGED: begin
								If In_Defense_Radius(tileX, tileY, defense.groupID, 0, defense.radius) Then begin
									groupDefendsXY := True;
								end Else begin(*
								Check to see if (tileX, tileY) is one of the 8 tiles around each and every unit in the ranged group.
								- Note that if two AI ranged groups are side by side, and one gets hit by a knight, both may be halted as a result (depending on where the knight was).*)
									For g := 0 to S.GroupMemberCount(defense.groupID) - 1 do
										If Around_Unit_HitBox(tileX, tileY, defense.groupID, g) Then begin
											groupDefendsXY := True;
											Break;
										end;
								end;
							end;
							RANGED_ATTACKED_BY_RANGED: begin
								If In_Defense_Radius(tileX, tileY, defense.groupID, 0, defense.radius) Then begin
									groupDefendsXY := True;
								end Else begin(*
								If human ranged shot AI ranged AND the current group being scanned is ranged, consider every member in the group (not just the leader), because any one of them could have been shot at.
								- In addition, consider their firing radius (instead of their defense radius).*)
									For g := 0 to S.GroupMemberCount(defense.groupID) - 1 do
										If In_Firing_Radius(tileX, tileY, defense.groupID, g) Then begin
											groupDefendsXY := True;
											Break;
										end;
								end;
							end;
							RANGED_NOT_ATTACKED: begin
								If In_Defense_Radius(tileX, tileY, defense.groupID, 0, defense.radius)
								Then groupDefendsXY := True;
							end;
						end;
					end Else begin
						If In_Defense_Radius(tileX, tileY, defense.groupID, 0, defense.radius)
						Then groupDefendsXY := True;
					end;
					If groupDefendsXY Then begin
						SetLength(defendingGroups, Length(defendingGroups) + 3);
						defendingGroups[High(defendingGroups) - 2] := defense.groupID;
						defendingGroups[High(defendingGroups) - 1] := defense.x;
						defendingGroups[High(defendingGroups) - 0] := defense.y;
						currentlyTaggedGroups := currentlyTaggedGroups + '|' + IntToStr(defense.groupID) + '|';
						// A.Log('(' + IntToStr(tileX) + ', ' + IntToStr(tileY) + ')' + ' is within player ' +
						// IntToStr(player + 1) + '''s ' + GroupType_String(defense.groupType) + ' group''s defense radius of ' +
						// IntToStr(defense.radius) + '.  Group location: (' + IntToStr(defense.x) + ', ' + IntToStr(defense.y) + ').');
					end;
				end;
			end;
			i := i + 2;
		end;
		Result := defendingGroups;
	end;


//----------------
//Main Subroutines
//----------------
	Function Tile_XY_Was_Recently_Attacked(x, y: Integer): Boolean;
	var	i: Integer;
	begin
		While i <= High(recentlyAttackTiles) - 2 do begin
			If (recentlyAttackTiles[i] = x) And (recentlyAttackTiles[i + 1] = y) Then begin
				Result := True;
				Exit;
			end;
			i := i + 3;
		end;
	end;

	Function Tile_Is_Neutral(attackerUnitID: Integer): Boolean;
	var i: Integer;
	begin //Either if tile has been marked neutral OR if tile has not yet been marked as neutral but is in fact neutral.
		For i := 0 to High(neutralTiles) do
			If Pos('|' + IntToStr(S.UnitPositionX(attackerUnitID)) + ',' + IntToStr(S.UnitPositionY(attackerUnitID)) + '|', neutralTiles[i]) > 0 Then begin
				Result := True;
				Exit;
			end;
	end;

	//Don't continue to recheck if a tile is in at least one AI group's defense radius!
	//But this assumes that new defense locations are not made during the script!
	Procedure Mark_Off_Neutral_Tile(attackerUnitID: Integer);
	begin
		If Tile_Is_Neutral(attackerUnitID) Then Exit;
		If Length(neutralTiles[High(neutralTiles)]) + 9 > 65535 Then SetLength(neutralTiles, Length(neutralTiles) + 1);
		neutralTiles[High(neutralTiles)] := neutralTiles[High(neutralTiles)] + '|' + IntToStr(S.UnitPositionX(attackerUnitID)) + ',' + IntToStr(S.UnitPositionY(attackerUnitID)) + '|';
	end;

	Function Get_Preferred_Available_Group(arr: Array of Integer; groupID: Integer): TKMGroupType;
	var i, groupType: Integer; groupTypePriority: Array of TKMGroupType;
	begin
		Case S.GroupTypeEx(groupID) of
			gtRanged: groupTypePriority := [gtRanged, gtMounted, gtMelee, gtAntiHorse];
			gtMelee: groupTypePriority := [gtMounted, gtMelee, gtAntiHorse, gtRanged];
			gtAntiHorse: groupTypePriority := [gtMelee, gtAntiHorse, gtMounted, gtRanged];
			gtMounted: groupTypePriority := [gtAntiHorse, gtMounted, gtMelee, gtRanged];
		end;
		For groupType := 0 to 3 do begin
			i := 0;
			While i <= Length(arr) - 2 do begin
				If S.GroupTypeEx(arr[i]) = groupTypePriority[groupType] Then begin
					Result := groupTypePriority[groupType];
					Exit;
				end;
				i := i + 3;
			end;
		end;
		Result := gtNone;
	end;

	Function Continue_To_Monitor_Decoys_And_Pursuing_Groups(humanDecoyGroupID, pursuingGroupID: Integer): Boolean;
	begin
		If S.GroupDead(humanDecoyGroupID) Or S.GroupDead(pursuingGroupID) //Either group is dead
		Then Result := True
		Else If S.GroupOrder(pursuingGroupID) = goAttackUnit Then Result := True; //Both groups are alive,
	end;

	Procedure Mark_Off_Human_Ranged_Decoy_And_AI_Pursuing_Group;
	var i: Integer;
	begin //(humanDecoyGroupID, aiPursuingGroupID),(..,..),...
		While i < Length(recentlyChasedOffSingleLeaders) - 1 do begin
			If Continue_To_Monitor_Decoys_And_Pursuing_Groups(recentlyChasedOffSingleLeaders[i], recentlyChasedOffSingleLeaders[i + 1]) = False Then begin
				recentlyChasedOffSingleLeaders[i] := recentlyChasedOffSingleLeaders[High(recentlyChasedOffSingleLeaders) - 1];
				recentlyChasedOffSingleLeaders[i + 1] := recentlyChasedOffSingleLeaders[High(recentlyChasedOffSingleLeaders)];
				SetLength(recentlyChasedOffSingleLeaders, Length(recentlyChasedOffSingleLeaders) - 2);
			end;
			i := i + 2;
		end;
	end;

	Function GroupLeader_Is_On_A_Defense_Location_XY(groupID: Integer): Boolean;
	var i, unitX, unitY: Integer;
	begin
		unitX := S.UnitPositionX(S.GroupMember(groupID, 0));
		unitY := S.UnitPositionY(S.GroupMember(groupID, 0));
		While i <= High(defenseLocationTiles) - 1 do begin //Radius of Sqrt(18) ensures 3 tiles all around defense tile.
			If Squared_Distance(defenseLocationTiles[i], defenseLocationTiles[i + 1], unitX, unitY) <= 18 Then begin
				Result := True;
				Exit;
			end;
			i := i + 2;
		end;
	end;

	Procedure Record_Attack(targetUnitOrHouseID, attackerUnitID: Integer; typeAttacked: String; aiAttackedHuman, haltGroupsImmediately: Boolean);
	var i, indexx, rangedAttackStatus: Integer; attack, groupIDsToHalt: Array of Integer; preferedGroupType: TKMGroupType; groupChosen: Boolean;
	begin
		SetLength(attack, GROUP_IDS_TO_HALT_ + 1);
		//The "ATTACKER" is considered the human (regarding defense radii), no matter what.
		//The "TARGETED PLAYER" is considered the AI (...).
		If aiAttackedHuman Then begin //If AI attacks a human player's SOLDIER ONLY!
			//(This procedure will not be called if the AI attacks a human player's villager or house.)
			//Coordinates are wherever the human player's unit was in contact with the enemy.
			If S.GroupDead(S.UnitsGroup(targetUnitOrHouseID)) Then Exit; //No need to record if human player's bowmen gets killed before his arrow hits a tower, for example.
			attack[X__] := S.UnitPositionX(targetUnitOrHouseID);
			attack[Y__] := S.UnitPositionY(targetUnitOrHouseID);
			If Tile_XY_Was_Recently_Attacked(attack[X__], attack[Y__]) Then Exit; //Major Optimization Line!
			attack[ATTACKER_UNIT_ID_] := targetUnitOrHouseID;
			attack[ATTACKER_GROUP_ID_] := S.UnitsGroup(targetUnitOrHouseID);
			attack[ATTACKER_PLAYER_] := S.UnitOwner(targetUnitOrHouseID);
			attack[TARGETED_PLAYER_] := S.UnitOwner(attackerUnitID);
			attack[TARGETED_GROUP_ID_] := S.UnitsGroup(attackerUnitID);
			attack[TARGETED_UNIT_TYPE_] := S.UnitType(attackerUnitID);
		end Else begin //Human Attacked AI's villager, soldier, or house.
			//Coordinates are STILL wherever the human player's unit was in contact with the enemy.
			If S.GroupDead(S.UnitsGroup(attackerUnitID)) Then Exit; //No need to record if human player's bowmen gets killed before his arrow hits a tower, for example.
			attack[X__] := S.UnitPositionX(attackerUnitID);
			attack[Y__] := S.UnitPositionY(attackerUnitID);
			If Tile_XY_Was_Recently_Attacked(attack[X__], attack[Y__]) Then Exit; //Major Optimization Line!
			attack[ATTACKER_UNIT_ID_] := attackerUnitID;
			attack[ATTACKER_GROUP_ID_] := S.UnitsGroup(attackerUnitID);
			attack[ATTACKER_PLAYER_] := S.UnitOwner(attackerUnitID);
			If typeAttacked = 'unit' Then begin
				attack[TARGETED_UNIT_TYPE_] := S.UnitType(targetUnitOrHouseID);
				attack[TARGETED_PLAYER_] := S.UnitOwner(targetUnitOrHouseID);
				If attack[TARGETED_UNIT_TYPE_] > 13 Then begin //Only if unit is a soldier.
					attack[TARGETED_GROUP_ID_] := S.UnitsGroup(targetUnitOrHouseID)
					If Unit_Is_Ranged(targetUnitOrHouseID) Then begin //AI ranged,
						If Unit_Is_Ranged(attackerUnitID)
						Then rangedAttackStatus := RANGED_ATTACKED_BY_RANGED  //was attacked by human ranged,
						Else rangedAttackStatus := RANGED_ATTACKED_BY_NONRANGED;//was attacked by human non-ranged,
					end;
				end;
			end Else begin
				attack[TYPE_ATTACKED_] := 1;
				attack[TARGETED_PLAYER_] := S.HouseOwner(targetUnitOrHouseID);
			end;
		end;

		groupIDsToHalt := Player_Get_All_Defending_Groups(attack[TARGETED_PLAYER_], attack[X__], attack[Y__], rangedAttackStatus);

		//If Human player is using very few units (maybe even just a single leader) to lure,
		If haltGroupsImmediately Then begin
			indexx := Position_Int(recentlyChasedOffSingleLeaders, attack[ATTACKER_GROUP_ID_]);
			If indexx > -1 Then begin //If human ranged group is already being tracked,
				If Continue_To_Monitor_Decoys_And_Pursuing_Groups(recentlyChasedOffSingleLeaders[indexx], recentlyChasedOffSingleLeaders[indexx + 1]) Then begin
					groupChosen := True;
					preferedGroupType := S.GroupTypeEx(recentlyChasedOffSingleLeaders[indexx + 1]);
				end Else preferedGroupType := Get_Preferred_Available_Group(groupIDsToHalt, attack[ATTACKER_GROUP_ID_]); //Get one group to go after him (or them).
			end Else preferedGroupType := Get_Preferred_Available_Group(groupIDsToHalt, attack[ATTACKER_GROUP_ID_]); //Get one group to go after him (or them).

			If preferedGroupType = gtNone Then Exit; //There are no available groups in range.  Exit.

			While i <= Length(groupIDsToHalt) - 2 do begin
				If (S.GroupTypeEx(groupIDsToHalt[i]) = preferedGroupType) And (groupChosen = False)	Then begin
					//Keep track of the human archer decoy and the AI pursing group.
					SetLength(recentlyChasedOffSingleLeaders, Length(recentlyChasedOffSingleLeaders) + 2);
					recentlyChasedOffSingleLeaders[High(recentlyChasedOffSingleLeaders) - 1] := attack[ATTACKER_GROUP_ID_];
					recentlyChasedOffSingleLeaders[High(recentlyChasedOffSingleLeaders)] := groupIDsToHalt[i];
					i := i + 3;
					groupChosen := True;
				end	Else begin
					//Halt all other groups IF they are on their defense locations.
					If GroupLeader_Is_On_A_Defense_Location_XY(groupIDsToHalt[i]) Then begin
						A.GroupOrderHalt(groupIDsToHalt[i]);

						//Remove them from the currently tagged groups list so that they can potentially be
						//recorded in the next attack, as they will NOT be recorded in this attack's recording.
						currentlyTaggedGroups := U.StringReplace(currentlyTaggedGroups, '|' + IntToStr(groupIDsToHalt[i]) + '|', '', True, False);
						groupIDsToHalt[i] := groupIDsToHalt[High(groupIDsToHalt) - 2];
						groupIDsToHalt[i + 1] := groupIDsToHalt[High(groupIDsToHalt) - 1];
						groupIDsToHalt[i + 2] := groupIDsToHalt[High(groupIDsToHalt)];
						SetLength(groupIDsToHalt, Length(groupIDsToHalt) - 3);
					end Else i := i + 3;
				end;
			end;

			//If group has already been chosen the following will be the case.
			//Do NOT mark off the tile as neutral!
			If Length(groupIDsToHalt) = 0 Then Exit;
		end;

		attack[GROUP_IDS_TO_HALT_] := Length(groupIDsToHalt);
		If (attack[GROUP_IDS_TO_HALT_] = 0) Then begin
			If aiAttackedHuman
			Then Mark_Off_Neutral_Tile(targetUnitOrHouseID)
			Else Mark_Off_Neutral_Tile(attackerUnitID);
			Exit; //Don't record the attack if it happened outside of all AI groups' defense circles.
		end;

		SetLength(attack, GROUP_IDS_TO_HALT_ + 1 + attack[GROUP_IDS_TO_HALT_]);
		For i := 0 to High(groupIDsToHalt) do attack[i + GROUP_IDS_TO_HALT_ + 1] := groupIDsToHalt[i];

		attack[TIME__] := S.GameTime;

		If haltGroupsImmediately = False Then begin
			SetLength(recentlyAttackTiles, Length(recentlyAttackTiles) + 3);
			recentlyAttackTiles[High(recentlyAttackTiles) - 2] := attack[X__];
			recentlyAttackTiles[High(recentlyAttackTiles) - 1] := attack[Y__];
			recentlyAttackTiles[High(recentlyAttackTiles)] := attack[TIME__];
		end;

		SetLength(attacks[attack[TARGETED_PLAYER_]], Length(attacks[attack[TARGETED_PLAYER_]]) + 1);
		attacks[attack[TARGETED_PLAYER_]][High(attacks[attack[TARGETED_PLAYER_]])] := attack;
	end;
		Procedure AntiLure__OnUnitAttacked(targetUnitID, attackerUnitID: Integer);
		var aiAttackedHuman, haltGroupsImmediately: Boolean;
		begin
		//In the case when human player attempts to use very few (like just 1) unit to lure,
			If S.PlayerIsAI(S.UnitOwner(targetUnitID)) //If AI unit got attacked
			And (S.PlayerIsAI(S.UnitOwner(attackerUnitID)) = False) //by a human player's unit
			Then begin
				If Unit_Is_Ranged(attackerUnitID) Then begin
					If (S.GroupMemberCount(S.UnitsGroup(attackerUnitID)) < RANGED_DECOY_COUNT + 1)
					And GroupLeader_Is_On_A_Defense_Location_XY(S.UnitsGroup(targetUnitID))
					And (S.GroupOrder(S.UnitsGroup(targetUnitID)) = goAttackUnit)
					Then haltGroupsImmediately := True;
				end Else begin
					If (S.GroupMemberCount(S.UnitsGroup(attackerUnitID)) < NONRANGED_DECOY_COUNT + 1)
					And GroupLeader_Is_On_A_Defense_Location_XY(S.UnitsGroup(targetUnitID))
					And (S.GroupOrder(S.UnitsGroup(targetUnitID)) = goAttackUnit)
					Then haltGroupsImmediately := True;
				end;
			end;

		//As you can see from comments below, there is no support for when AI attacks AI unit.
			If (S.PlayerIsAI(S.UnitOwner(targetUnitID)) = False) Then begin//If a human player got attacked
				If (S.PlayerIsAI(S.UnitOwner(attackerUnitID)) = False) //by a human player
				Then Exit; //Don't record

				If Unit_Is_Ranged(attackerUnitID) //by an AI player's ranged unit.
				And S.WarriorInFight(attackerUnitID, False)
				Then Exit; //Don't record
			end;

			If (S.PlayerIsAI(S.UnitOwner(targetUnitID)) = False) //If a human player got attacked
			And (S.PlayerIsAI(S.UnitOwner(attackerUnitID))) //by an AI player
			And S.WarriorInFight(attackerUnitID, False) //And there's actual contact
			Then begin
				//Don't record if a human player's villager got attacked, as they don't trigger AI defense.
				If S.UnitType(targetUnitID) < 14 Then Exit;

				aiAttackedHuman := True;
				//The true tile of "offense" is the one the human player's unit is on.
				//If the tile has already been determined to not be in any defense radius, don't record.
				If Tile_Is_Neutral(targetUnitID) Then Exit;
			end Else If Tile_Is_Neutral(attackerUnitID) Then Exit;

			Record_Attack(targetUnitID, attackerUnitID, 'unit', aiAttackedHuman, haltGroupsImmediately);
		end; {$EVENT evtUnitAttacked:AntiLure__OnUnitAttacked}

		Procedure AntiLure__OnHouseDamaged(targetHouseID, attackerUnitID: Integer);
		var haltGroupsImmediately: Boolean;
		begin //As you can see from comments below, there is no support for when AI attacks AI house.
			If S.PlayerIsAI(S.HouseOwner(targetHouseID)) //House owned by AI player.
			And (S.PlayerIsAI(S.UnitOwner(attackerUnitID)) = False) //House was attacked by human player.
			And (Tile_Is_Neutral(attackerUnitID) = False) //Tile is potentially in defense radius territory.
			Then begin
				If Unit_Is_Ranged(attackerUnitID) Then begin
					If (S.GroupMemberCount(S.UnitsGroup(attackerUnitID)) < RANGED_DECOY_COUNT + 1)
					Then haltGroupsImmediately := True;
				end Else begin
					If (S.GroupMemberCount(S.UnitsGroup(attackerUnitID)) < NONRANGED_DECOY_COUNT + 1)
					Then haltGroupsImmediately := True;
				end;
				Record_Attack(targetHouseID, attackerUnitID, 'house', False, haltGroupsImmediately);
			end;
		end; {$EVENT evtHouseDamaged:AntiLure__OnHouseDamaged}


	Function Attacker_Moved_Far_Enough_Away(player: Integer; attack: Array of Integer; randI: Single; group: Integer): Boolean;
	var closestHouseID: Integer;
	begin
		If Unit_Is_Dead(attack[ATTACKER_UNIT_ID_]) Then begin
			Result := True; //Prevents a lot of log file error messages!
			Exit;
		end;
		If KaM_Distance(
			S.UnitPositionX(S.GroupMember(attack[group], 0)),
			S.UnitPositionY(S.GroupMember(attack[group], 0)),
			attack[group + 1], //Defense Location x-coordinate.
			attack[group + 2] //Defense Location y-coordinate.
		) > weights[DEFENSE_POSITION_DISTANCE_][player] Then begin
			Result := True;
			Exit;
		end;
		If attack[TYPE_ATTACKED_] = 0 Then begin //If unit was attacked
			If attack[TARGETED_UNIT_TYPE_] < 14 Then begin //Unit WAS a villager.
				closestHouseID := S.ClosestHouse(attack[TARGETED_PLAYER_], attack[X__], attack[Y__], -1);
				If closestHouseID > 0 Then begin
					Result := KaM_Distance(
						S.HousePositionX(closestHouseID),
						S.HousePositionY(closestHouseID),
						S.UnitPositionX(attack[ATTACKER_UNIT_ID_]),
						S.UnitPositionY(attack[ATTACKER_UNIT_ID_])
					) >= weights[VILLAGER_DISTANCE_][player] * randI;
				end;
			end	Else begin //A soldier was attacked.
				If S.GroupDead(attack[TARGETED_GROUP_ID_]) Then begin
					//If the group he attacked is DEAD, consider the tile (x,y) where the attack happened.
					Result := KaM_Distance(
						attack[X__],
						attack[Y__],
						S.UnitPositionX(attack[ATTACKER_UNIT_ID_]),
						S.UnitPositionY(attack[ATTACKER_UNIT_ID_])
					) >= weights[UNIT_DISTANCE_][player] * randI;
				end	Else begin
					//If the group he attacked is still alive, consider its LEADER's location.
					Result := KaM_Distance(
						S.UnitPositionX(S.GroupMember(attack[TARGETED_GROUP_ID_], 0)),
						S.UnitPositionY(S.GroupMember(attack[TARGETED_GROUP_ID_], 0)),
						S.UnitPositionX(attack[ATTACKER_UNIT_ID_]),
						S.UnitPositionY(attack[ATTACKER_UNIT_ID_])
					) >= weights[UNIT_DISTANCE_][player] * randI;
				end;
			end;
		end	Else begin
			//A building/house was attacked.  Consider where the tile (x,y) were the attack happened.
			Result := KaM_Distance(
				attack[X__],
				attack[Y__],
				S.UnitPositionX(attack[ATTACKER_UNIT_ID_]),
				S.UnitPositionY(attack[ATTACKER_UNIT_ID_])
			) >= weights[BUILDING_DISTANCE_][player] * randI;
		end;
	end;

	Function Link_Before_Dead_Is_Being_Attempted(attack: Array of Integer): Boolean;
	begin
		Result := Unit_Is_Dead(attack[ATTACKER_UNIT_ID_])
		And (S.GroupDead(attack[ATTACKER_GROUP_ID_]) = False)
		And (S.GroupInFight(attack[ATTACKER_GROUP_ID_], False) = False);
	end;

	Procedure Remove_Group(player, attack, group: Integer);
	begin
		currentlyTaggedGroups := U.StringReplace(currentlyTaggedGroups, '|' + IntToStr(attacks[player][attack][group]) + '|', '', True, False);
		attacks[player][attack][group] := -1;
	end;

	Procedure Halt_Group_If_Applicable(player, attack, group: Integer);
	begin
		If S.GroupOrder(attacks[player][attack][group]) = goAttackHouse
		Then Remove_Group(player, attack, group) //Don't halt a group attacking a house (no matter what).
		Else begin
			//Halting a group in a fight may cause lag.
			//But it also causes volunterabilites to the LBD trick.
			//So we don't halt them when they are in a fight!  (We save the halt for a time when they have finished fighting... should at least one of the members in the group still be alive at that time.)
			If (S.GroupInFight(attacks[player][attack][group], False) = False) Then begin
				A.GroupOrderHalt(attacks[player][attack][group]);
				Remove_Group(player, attack, group);
			end
		end;
	end;

	Function All_Groups_Have_Been_Halted(groupsToBeHalted: Array of Integer; firstGroup, lastGroup: Integer): Boolean;
	var i: Integer;
	begin
		i := firstGroup;
		While i <= lastGroup do begin
			If (groupsToBeHalted[i] <> -1) Then Exit;
			i := i + 3;
		end;
		Result := True;
	end;

	Procedure Halt_Groups;
	var player, attack, group, groupType, firstGroup, lastGroup, randI: Integer;
	begin
		For player := aiPlayers[0] to aiPlayers[High(aiPlayers)] do begin
			For attack := Low(attacks[player]) to High(attacks[player]) do begin
				firstGroup := GROUP_IDS_TO_HALT_ + 1;
				lastGroup := High(attacks[player][attack]) - 2;
				If All_Groups_Have_Been_Halted(attacks[player][attack], firstGroup, lastGroup)
				Or (Link_Before_Dead_Is_Being_Attempted(attacks[player][attack]) And (weights[LINK_BEFORE_DEAD_ALLOWED_][player] = YES))
				Then attacks[player] := Remove_Int_2D(attacks[player], attack) //Remove attack
				Else begin
					group := firstGroup;
					While group <= lastGroup do begin
						If attacks[player][attack][group] <> -1 Then begin
							If S.GroupDead(attacks[player][attack][group])
							Then Remove_Group(player, attack, group)
							Else begin
								For groupType := 0 to 3 do begin
									If S.GroupTypeEx(attacks[player][attack][group]) = groupTypes[groupType] Then begin
										If weights[RANDOM_DISTANCE_MULTIPLIER_][player] = YES Then randI := U.RandomRangeI(1, 2) Else randI := 1;
										If Attacker_Moved_Far_Enough_Away(player, attacks[player][attack], randI, group) Then begin
											If weights[RANDOM_DELAY_MULTIPLIER_][player] = YES Then randI := U.RandomRangeI(1, 3) Else randI := 1;
											If (weights[RESET_TIMER_][player]  = YES) And (attacks[player][attack][TIME_WAS_RESET_] = NO) Then begin
												attacks[player][attack][TIME__] := S.GameTime + weights[groupType][player] * 10 * randI;
												attacks[player][attack][TIME_WAS_RESET_] := 1;
											end	Else begin
												If S.GameTime >= attacks[player][attack][TIME__] + weights[groupType][player] * 10 * randI Then begin
													Halt_Group_If_Applicable(player, attack, group);
													Break; //Don't search for the group type (again). It's already been found!
												end;
											end;
										end;
									end;
								end;
							end;
						end;
						group := group + 3;
					end;
				end;
			end;
		end;
	end;

	//We don't want any given tile (x,y) that an attack was recorded to remain
	//for too long, because if a new attack is made on that same tile, all AI
	//groups that respond to THAT attack will be vulnerable to lure.
		Procedure Remove_Recent_Attacked_Tiles;
		var i, newLow, gameTime: Integer; arr: Array of Integer; //str: String;
		begin
			gameTime := S.GameTime;
			i := High(recentlyAttackTiles);
			While i >= 0 do begin
				If gameTime - recentlyAttackTiles[i] >= 100 Then Break;
				i := i - 3;
			end;
			If i = -1 Then Exit;
			newLow := i + 1;

			// A.Log('-------------------------------------------');
			// A.Log('Before');
			// i := 0;
			// While i <= High(recentlyAttackTiles) - 2 do begin
				// str := str + IntToStr(recentlyAttackTiles[i]) + ',';
				// str := str + IntToStr(recentlyAttackTiles[i + 1]) + ',';
				// str := str + IntToStr(recentlyAttackTiles[i + 2]) + '|';
				// i := i + 3;
			// end;
			// A.Log(str);

			// A.Log('gameTime: ' + IntToStr(gameTime) + ', newLow: ' + IntToStr(newLow));
			// (0,1,2),(3,4,5),(6,7,8),(9,10,11),(12,13,14),(15,16,17),......

			SetLength(arr, High(recentlyAttackTiles) - newLow + 1);
			For i := newLow to High(recentlyAttackTiles) do arr[i - newLow] := recentlyAttackTiles[i];
			recentlyAttackTiles := arr;

			// A.Log('After');
			// i := 0;
			// str := '';
			// While i <= High(recentlyAttackTiles) - 2 do begin
				// str := str + IntToStr(recentlyAttackTiles[i]) + ',';
				// str := str + IntToStr(recentlyAttackTiles[i + 1]) + ',';
				// str := str + IntToStr(recentlyAttackTiles[i + 2]) + '|';
				// i := i + 3;
			// end;
			// A.Log(str);
		end;

	Procedure Halt_All_Ranged_Defender_Groups_Not_Recorded;
	var i, j: Integer; defense: TKMDefencePositionInfo;
	begin
		For i := 0 to High(aiPlayers) do begin
			For j := 0 to High(defenderDefensePositions[aiPlayers[i]]) do begin
				defense := S.AIDefencePositionGetByIndex(aiPlayers[i], defenderDefensePositions[aiPlayers[i]][j]);
				If (defense.groupID > 0) //Group exists.
				And (defense.groupType <> gtNone) //Yeah, again, but I don't know why.
				And (Pos('|' + IntToStr(defense.groupID) + '|', currentlyTaggedGroups) = 0) //Group isn't tagged.
				Then A.GroupOrderHalt(defense.groupID);
			end;
		end;
	end;

	Procedure AntiLure__OnTick;
	begin
		If S.GameTime Mod 10 = 0 Then begin
			Halt_Groups;
			Mark_Off_Human_Ranged_Decoy_And_AI_Pursuing_Group;
			If S.GameTime Mod 100 = 0 Then begin
				Remove_Recent_Attacked_Tiles;
				Halt_All_Ranged_Defender_Groups_Not_Recorded;
			end;
		end;
	end; {$EVENT evtTick:AntiLure__OnTick}

	Procedure Remove_AutoAttackRange;
	var i: Integer;
	begin
		For i := 0 to High(aiPlayers) do A.AIAutoAttackRange(aiPlayers[i], 1);
	end;

	Procedure Get_All_Starting_Defense_Location_Tiles;
	var i, j, len, previousLen: Integer; defense: TKMDefencePositionInfo;
	begin(*
		Get all put all defense tiles XY into an array so that we can check to see that if any AI group's leader is on one of those tiles (or tiles within a certain radius distance from those tiles... due to fast moving units like mounted), then HALT all groups.  (This is for when 1 bowmen trigger them to move.)*)
		SetLength(defenderDefensePositions, S.LocationCount);
		For i := Low(aiPlayers) to High(aiPlayers) do begin
			len := len + 2 * S.StatAIDefencePositionsCount(aiPlayers[i]);
			SetLength(defenseLocationTiles, len);
			j := 0;
			While j <= len - previousLen - 1 do begin
				defense := S.AIDefencePositionGetByIndex(aiPlayers[i], j / 2);
				defenseLocationTiles[previousLen + j] := defense.x;
				defenseLocationTiles[previousLen + j + 1] := defense.y;
				If (defense.PositionType = dtFrontLine)//If it's a defender group
				Then defenderDefensePositions[aiPlayers[i]] := Append_Int(defenderDefensePositions[aiPlayers[i]] , j / 2);
				j := j + 2;
			end;
			previousLen := len;
		end;
	end;

	Function Split_S(spacing: Integer; str: String): Array of String;
	var i: Integer; arr: Array of String;
	begin (*
		The index of tile (x,y) in allMapTiles is defined by:  (S.MapWidth - 1) * (y - 1) + x

		x = Modulous(k, mapWidth) and y = -Floor(-k / mapWidth).

		zzcmDefencePositionInfoArray.script contains (well, when it's generated by my "Script Updater.hta" app) a string array whose elements are all equal in string length.  Each element is an array of integers, but not all elements have the same number of arguments.  Therefore, in order for all elements to be the same string length, most have blank spaces at the end to "fill in the gaps".  Hence why Trim() is used below AND that "spacing" is a parameter of this Function.

		A normal SplitString function will of course search for the next occurrence of the delimeter in the string, but by us having a string array whose elements are all made the same length (by adding extra spaces to all so that they are all equal in length to the largest element's length), we don't have to use Pos() or additional assignments to slow down the split.  Trim() takes care of the rest.

		This is important, because this is called in OnMissionStart.  For a big map, it can take up to 40 seconds for the game to start!  But with this method, it may take just 1 additional second (at most), even for very large maps like "Border of Life".*)
		SetLength(arr, Length(str));
		For i := 1 to (S.MapHeight - 1) * mapWidth + 1 do begin
			arr[i] := Trim(Substring(str, (i - 1) * (spacing + 1) + 1,  (i - 1) * (spacing + 1) + spacing));
		end;
		SetLength(arr, i - 1);
		Result := arr;
	end;

	Procedure Remove_AI_Players_To_Ignore(aiPlayersToIgnore: Array of Integer);
	var i: Integer; str: String;
	begin
		str := '|';
		For i := 0 to High(aiPlayersToIgnore) do str := str + IntToStr(aiPlayersToIgnore[i]) + '|';
		i := 0;
		While i <= High(aiPlayers) do begin
			If Pos('|' + IntToStr(aiPlayers[i]) + '|', str) > 0
			Then aiPlayers := U.ArrayRemoveIndexI(i, aiPlayers)
			Else i := i + 1;
		end;
	end;

	Procedure AntiLure__OnMissionStart;
	var aiPlayersToIgnoreDefensePositions: Array of Integer;
	begin
		aiPlayersToIgnoreDefensePositions := [1, 2];
		SetLength(neutralTiles, 1);
		aiPlayers := Get_All_Players(True);
		humanPlayers := Get_All_Players(False);
		Remove_AI_Players_To_Ignore(aiPlayersToIgnoreDefensePositions);

		//For the main halting procedure.
		SetLength(attacks, S.LocationCount);
		groupTypes := [gtRanged, gtAntiHorse, gtMelee, gtMounted];

		//For user settings,
		If REMOVE_AUTO_ATTACK_RANGE = YES Then Remove_AutoAttackRange;
		Initialize_CONSTANTS;

		 //This allows us to halt all defender groups periodically.
		Get_All_Starting_Defense_Location_Tiles;

		//For a major optimization.  Elliminates the need to loop through all defensive locations of all players to see which group defends a random tile that happens to be where an assault by (or to) a human player's unit in AI territory.
		mapWidth := S.MapWidth - 1;
		defPosInfoArray := Split_S(largestElm, mapTileDefPosInfo);
		// A.Log(defPosInfoArray[High(defPosInfoArray)]);
		mapTileDefPosInfo := ''; //Very important... game crashes at random (from "out of range error") otherwise!
	end; {$EVENT evtMissionStart:AntiLure__OnMissionStart}
{$ENDIF}